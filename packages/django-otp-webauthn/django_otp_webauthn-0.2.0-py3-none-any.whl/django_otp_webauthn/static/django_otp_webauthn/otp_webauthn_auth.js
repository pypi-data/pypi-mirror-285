(()=>{"use strict";var M={};async function x(){let e=null;const t=document.getElementById("otp_webauthn_config");if(t)return e=JSON.parse(t.innerText),Object.freeze(e);throw new Error("otp_webauthn_config element not found")}async function T(e){let t="";const n=e.csrfCookieName;if(document.cookie&&document.cookie!==""){const o=document.cookie.split(";");for(let r=0;r<o.length;r++){const f=o[r].trim();if(f.substring(0,n.length+1)===n+"="){t=decodeURIComponent(f.substring(n.length+1));break}}}return t}function w(e){const t=new Uint8Array(e);let n="";for(const r of t)n+=String.fromCharCode(r);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function S(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,o=t.padEnd(t.length+n,"="),r=atob(o),f=new ArrayBuffer(r.length),u=new Uint8Array(f);for(let h=0;h<r.length;h++)u[h]=r.charCodeAt(h);return f}function C(){return window?.PublicKeyCredential!==void 0&&typeof window.PublicKeyCredential=="function"}function D(e){const{id:t}=e;return{...e,id:S(t),transports:e.transports}}function N(e){return e==="localhost"||/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(e)}class c extends Error{constructor({message:t,code:n,cause:o,name:r}){super(t,{cause:o}),this.name=r??o.name,this.code=n}}function K({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new c({message:"Registration ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else if(e.name==="ConstraintError"){if(n.authenticatorSelection?.requireResidentKey===!0)return new c({message:"Discoverable credentials were required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",cause:e});if(n.authenticatorSelection?.userVerification==="required")return new c({message:"User verification was required but no available authenticator supported it",code:"ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",cause:e})}else{if(e.name==="InvalidStateError")return new c({message:"The authenticator was previously registered",code:"ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",cause:e});if(e.name==="NotAllowedError")return new c({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="NotSupportedError")return n.pubKeyCredParams.filter(r=>r.type==="public-key").length===0?new c({message:'No entry in pubKeyCredParams was of type "public-key"',code:"ERROR_MALFORMED_PUBKEYCREDPARAMS",cause:e}):new c({message:"No available authenticator supported any of the specified pubKeyCredParams algorithms",code:"ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",cause:e});if(e.name==="SecurityError"){const o=window.location.hostname;if(N(o)){if(n.rp.id!==o)return new c({message:`The RP ID "${n.rp.id}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new c({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="TypeError"){if(n.user.id.byteLength<1||n.user.id.byteLength>64)return new c({message:"User ID was not between 1 and 64 characters",code:"ERROR_INVALID_USER_ID_LENGTH",cause:e})}else if(e.name==="UnknownError")return new c({message:"The authenticator was unable to process the specified options, or could not create a new credential",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}class F{createNewAbortSignal(){if(this.controller){const n=new Error("Cancelling existing WebAuthn API call for new one");n.name="AbortError",this.controller.abort(n)}const t=new AbortController;return this.controller=t,t.signal}cancelCeremony(){if(this.controller){const t=new Error("Manually cancelling existing WebAuthn API call");t.name="AbortError",this.controller.abort(t),this.controller=void 0}}}const k=new F,B=["cross-platform","platform"];function L(e){if(e&&!(B.indexOf(e)<0))return e}async function H(e){if(!C())throw new Error("WebAuthn is not supported in this browser");const n={publicKey:{...e,challenge:S(e.challenge),user:{...e.user,id:S(e.user.id)},excludeCredentials:e.excludeCredentials?.map(D)}};n.signal=k.createNewAbortSignal();let o;try{o=await navigator.credentials.create(n)}catch(p){throw K({error:p,options:n})}if(!o)throw new Error("Registration was not completed");const{id:r,rawId:f,response:u,type:h}=o;let l;typeof u.getTransports=="function"&&(l=u.getTransports());let _;if(typeof u.getPublicKeyAlgorithm=="function")try{_=u.getPublicKeyAlgorithm()}catch(p){O("getPublicKeyAlgorithm()",p)}let R;if(typeof u.getPublicKey=="function")try{const p=u.getPublicKey();p!==null&&(R=w(p))}catch(p){O("getPublicKey()",p)}let d;if(typeof u.getAuthenticatorData=="function")try{d=w(u.getAuthenticatorData())}catch(p){O("getAuthenticatorData()",p)}return{id:r,rawId:w(f),response:{attestationObject:w(u.attestationObject),clientDataJSON:w(u.clientDataJSON),transports:l,publicKeyAlgorithm:_,publicKey:R,authenticatorData:d},type:h,clientExtensionResults:o.getClientExtensionResults(),authenticatorAttachment:L(o.authenticatorAttachment)}}function O(e,t){console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${e}. You should report this error to them.
`,t)}function V(){if(!C())return new Promise(t=>t(!1));const e=window.PublicKeyCredential;return e.isConditionalMediationAvailable===void 0?new Promise(t=>t(!1)):e.isConditionalMediationAvailable()}function q({error:e,options:t}){const{publicKey:n}=t;if(!n)throw Error("options was missing required publicKey property");if(e.name==="AbortError"){if(t.signal instanceof AbortSignal)return new c({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if(e.name==="NotAllowedError")return new c({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if(e.name==="SecurityError"){const o=window.location.hostname;if(N(o)){if(n.rpId!==o)return new c({message:`The RP ID "${n.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else return new c({message:`${window.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e})}else if(e.name==="UnknownError")return new c({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}return e}async function U(e,t=!1){if(!C())throw new Error("WebAuthn is not supported in this browser");let n;e.allowCredentials?.length!==0&&(n=e.allowCredentials?.map(D));const o={...e,challenge:S(e.challenge),allowCredentials:n},r={};if(t){if(!await V())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');r.mediation="conditional",o.allowCredentials=[]}r.publicKey=o,r.signal=k.createNewAbortSignal();let f;try{f=await navigator.credentials.get(r)}catch(d){throw q({error:d,options:r})}if(!f)throw new Error("Authentication was not completed");const{id:u,rawId:h,response:l,type:_}=f;let R;return l.userHandle&&(R=w(l.userHandle)),{id:u,rawId:w(h),response:{authenticatorData:w(l.authenticatorData),clientDataJSON:w(l.clientDataJSON),signature:w(l.signature),userHandle:R},type:_,clientExtensionResults:f.getClientExtensionResults(),authenticatorAttachment:L(f.authenticatorAttachment)}}function W(){return C()?PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable():new Promise(e=>e(!1))}(async function(){const e="passkey-verification-button",t="passkey-verification-status-message",n="visible",o="passkey-verification-placeholder",r="passkey-verification-unavailable-template",f="passkey-verification-available-template",u="otp_webauthn.verification_start",h="otp_webauthn.verification_complete",l="otp_webauthn.verification_failed";async function _(a){if(!a.autocompleteLoginFieldSelector)return;const i=document.querySelector(a.autocompleteLoginFieldSelector);if(!i){console.error(`Could not find login field with selector ${a.autocompleteLoginFieldSelector}. WebAuthn autofill cannot continue.`);return}const s=i.getAttribute("autocomplete")||"";i.setAttribute("autocomplete",s+" webauthn"),i.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!0},bubbles:!0}));const y=await fetch(a.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":await T(a),Accept:"application/json"}});if(!y.ok){console.error("Unable to fetch options from server. Will not attempt autofill."),i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!0,response:y},bubbles:!0}));return}let E;try{E=await U(await y.json(),!0)}catch(m){console.error("Got error during the webauthn credential autofill call",m),i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!0,error:m},bubbles:!0}));return}const I=document.querySelector("input[name='next']");let v=a.completeAuthenticationUrl;I&&I.value&&(v+=`?next=${encodeURIComponent(I.value)}`);const A=await fetch(v,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":await T(a)},credentials:"same-origin",body:JSON.stringify(E)});if(!A.headers.get("content-type")?.includes("application/json")){i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!0,response:A},bubbles:!0})),alert(gettext("Verification failed. A server error occurred."));return}const b=await A.json();if(!A.ok&&"detail"in b){i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!0,response:A},bubbles:!0})),alert(b.detail);return}if(b&&b.id)i.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!0,response:A},bubbles:!0})),b.redirect_url&&(window.location.href=b.redirect_url);else{i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!0,response:A},bubbles:!0}));const m=b.error||gettext("An error occurred during verification.");alert(m)}}async function R(a){const i=document.getElementById(e);if(!i)return;const s=i.textContent||gettext("Verify with Passkey");i.addEventListener("click",async y=>{i.dispatchEvent(new CustomEvent(u,{detail:{fromAutofill:!1},bubbles:!0})),await d({buttonDisabled:!0,buttonLabel:gettext("Verifying...")});const E=await fetch(a.beginAuthenticationUrl,{method:"POST",credentials:"same-origin",headers:{"X-CSRFToken":await T(a),Accept:"application/json"}});if(!E.ok){await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:gettext("Verification failed. Could not retrieve parameters from the server.")}),i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!1,response:E},bubbles:!0}));return}let I;try{I=await U(await E.json())}catch(g){if(g instanceof Error||g instanceof c){switch(console.error(g),g.name){case"AbortError":await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:gettext("Verification aborted.")});break;case"NotAllowedError":await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:gettext("Verification canceled or not allowed.")});break;default:throw await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:gettext("Verification failed. An unknown error occurred.")}),g}i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!1,error:g},bubbles:!0}));return}}await d({buttonDisabled:!0,buttonLabel:gettext("Finishing verification...")});const v=document.querySelector("input[name='next']");let A=a.completeAuthenticationUrl;v&&v.value&&(A+=`?next=${encodeURIComponent(v.value)}`);const b=await fetch(A,{method:"POST",headers:{"Content-Type":"application/json","X-CSRFToken":await T(a)},credentials:"same-origin",body:JSON.stringify(I)});if(!b.headers.get("content-type")?.includes("application/json")){await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:gettext("Verification failed. An unknown server error occurred.")}),i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!1,response:b},bubbles:!0}));return}const m=await b.json();if(!b.ok){const g=m.detail||gettext("Verification failed. An unknown error occurred.");await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:g}),i.dispatchEvent(new CustomEvent(l,{detail:{fromAutofill:!1,response:b},bubbles:!0}));return}if(m&&m.id)await d({buttonDisabled:!1,buttonLabel:s,status:gettext("Verification successful!")}),i.dispatchEvent(new CustomEvent(h,{detail:{fromAutofill:!1,response:b,id:m.id},bubbles:!0})),m.redirect_url&&(window.location.href=m.redirect_url);else{const g=m.error||gettext("An error occurred during verification.");await d({buttonDisabled:!1,buttonLabel:s,requestFocus:!0,status:g})}})}async function d(a){const i=document.getElementById(e);if(!i)return;const s=document.getElementById(t);i.disabled=a.buttonDisabled,i.textContent=a.buttonLabel,s&&(a.status?(i.setAttribute("aria-describedby",t),s.classList.add(n),s.textContent=a.status,s.setAttribute("aria-live","assertive"),a.requestFocus&&i.focus()):(i.removeAttribute("aria-describedby"),s.removeAttribute("aria-live"),s.classList.remove(n)))}async function p(a){const i=document.getElementById(o),s=document.getElementById(f),y=document.getElementById(r);if(!i)throw new Error("Placeholder element not found");if(!s)throw new Error("Available template not found");if(a){const E=s.content.cloneNode(!0);i.replaceWith(E)}else if(y){const E=y.content.cloneNode(!0);i.replaceWith(E)}else i.remove()}const P=await x();P.autocompleteLoginFieldSelector&&await V()&&_(P),C()?(await p(!0),R(P)):await p(!1)})()})();

//# sourceMappingURL=otp_webauthn_auth.js.map