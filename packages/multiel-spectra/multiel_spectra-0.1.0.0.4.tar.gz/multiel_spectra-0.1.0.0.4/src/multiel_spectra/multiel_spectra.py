import spekpy as sp 
import larch 
from larch.xray import * 
import skbeam
from skbeam.core.constants import XrfElement
from skbeam.core.fitting import gaussian
import scipy 
from scipy.interpolate import interp1d
import scipy 
import pandas as pd
import numpy as np 
import matplotlib.pyplot as plt 
import bokeh
from .xrf_utils import *

air_density = material_get("air")[1]

### Single Spectra Use Version

def Primary_gen(k, theta, d, phys, mu_source, z, mas, target, filters):
    """This function creates the primary spectrum that will generate X-rays based on the spekpy 
    package. It returns two tuples of arrays: the primary spectrum (with characteristic and bremsstrahlung lines) 
    and a spectrum only of the bremsstrahlung component.

    Args:
        k (float): Tube potential in keV 
        theta (float): Anode angle in degrees
        d (float): Spectrum bin width in keV 
        phys (string): Physics Model
        mu_source (string): Source of photon coefficients
        z (float): Point-of-interest is at a focus-to-detector-distance
        mas (float): Exposure setting in mili-Ampers
        target (string): Anode target material
        filters (list): List of tuples (element_name, thickness) for Element Filtration in [mm]

    Returns:
        Tuple (primary_spectrum, bremsstrahlung_spectrum) of tuple of two arrays: X and Y XRF Spectrum components.
    """
    s=sp.Spek(kvp = k  , dk = d , th = theta, targ = target,  physics=phys, brem=True, char=True , mu_data_source=mu_source, z = z ,mas = mas ) # Create the spectrum model
    s.multi_filter(filters)
    # s.filter('Be',0.127).filter('Air',10) # Add the filtration [mm]
    Prim_s = s.get_spectrum(edges=True)
    bs=sp.Spek(kvp = k  , dk = d , th = theta, targ = target,  physics=phys, brem=True, char=False , mu_data_source=mu_source, z = z ,mas = mas ) # Create the spectrum model
    bs.multi_filter(filters)
    bPrim_s = bs.get_spectrum(edges=True)

    return Prim_s, bPrim_s

def sum_prima(element, prim_spectra_X, prim_spectra_y, x = np.arange(0, 30, 0.01), gauss_a = 0.05):
    """_This function generates the X-ray spectra given an element and the primary spectrum__

    Args:
        element (int, string): Element that will generate the Xrays (can be either the atomic number or symbol)
        prim_spectra_X (np.array): X component of Primary spectrum 
        prim_spectra_y (np.array): Y component of Primary spectrum 
        x (_type_, optional): Range of the spectra binning, the generated spectra will correspond to the Y component of this variable. Defaults to np.arange(0, 30, 0.01).
        gauss_a (float, optional): Width of the gaussian generated by each xray line. Defaults to 0.05.

    Returns:
        np.array: the xray spectra of an element as the sum of all peaks of an element within the given x range. 
    """
    spec_tot = np.zeros(len(x))
    e = XrfElement(element)
    lines = e.emission_line.all
    std = gauss_a
    area = std * np.sqrt(2 * np.pi)
    error = np.random.random(1)/100
    f = np.random.randint(3)
    for en,counts in zip(prim_spectra_X,prim_spectra_y): 
        ratio = [val for val in e.cs(en).all if val[1] > 0] #csb, cross section in barns 
        spec= np.zeros(len(x))
        for item in ratio:
            for data in lines:
                if item[0] == data[0]:
                    e_peak = data[1] + ((-1)**f)*error # que error meto [ +- 0.05] de desplazamiento de los picos ? 
                    spec += gaussian(x, area, e_peak, std) * item[1]
        spec_tot += spec*counts 
    return spec_tot

def multi_trans_gen(a,  Prim_s, gauss_l = 0.15):
    """
    Simulate X-ray fluorescence (XRF) generation and transmission through a list of elements.

    XRF Generation and Transmission through the elements given in 'a', using the Primary spectrum 
    given by 'Prim_s' with the background (bremsstrahlung) component given by 'bPrim_s'. The spectra transmission 
    goes from the last element of the 'a' array until the first. That is, the first element has no 
    transmission, and the last element is transmitted through the whole list given in 'a'. 

    Args:
        a (list): A list of element indices representing the elements through which XRF generation and 
                  transmission are to be simulated. Or Either a list of the names of the elements.
        Prim_s (tuple): Tuple containing two arrays representing the primary peaks and their corresponding probabilities.

    Returns:
        tuple: A tuple containing three elements:
               - air_spectra (array): The transmitted spectrum after XRF generation and absorption through the elements.
               - peaks_pos (array): A binary array indicating the presence of peaks in the spectrum.
               - c (array): A probability distribution representing the composition of the material.

    Note: The function simulates XRF generation and transmission through the specified elements and computes the transmitted spectrum.
          It considers the effect of XRF generation, absorption through the elements, and air absorption in the final transmitted spectrum.
          The function relies on other helper functions like 'sum_prima' and 'material_mu'.
          The 'air_density' variable is assumed to be defined elsewhere in the code.
    """  
    if all(isinstance(el, str) for el in a):
        new_a = []
        for el in a:
            new_a.append(reduced_list.index(el))
        a = new_a 
     
    mask = [b not in a for b in np.arange(0,41,1)]
 

    c = np.random.random(len(reduced_list)) #/np.sum(c) para normalizar
    c[mask]=0
    c = c/np.sum(c) 
    n = c[c> 0]
    
    el_list = []
    peaks_pos = np.zeros(len(peaks_dic))
    for el in a:
        el_list.append(reduced_list[el]) 
        mask_lines =  [a[:len(reduced_list[el])]==reduced_list[el] for a in peaks_dic.keys()  ] #ponemos las lineas que tiene que haber.
        peaks_pos[np.where(mask_lines)[0]]=1

  # y = materials
  # y = y/np.min(y[~np.array(mask)])
  # y = y/np.sum(y)
    posi = list(zip(*sorted(zip(a, np.arange(len(a))))))[1]
    n  = list(zip(*sorted(zip( n , posi))))[0]
    final_spectra = np.zeros(600)
    gaus = np.random.uniform(low = 0.03 , high = gauss_l  ) #he movido esto fuera para que todos los picos
    #sean de la misma anchura, es decir, medidos por el mismo aparato.
    for i in range(len(el_list)-1, -1, -1): 
        w = n[i]
        # pos = a[i]
        prod_s = sum_prima(element = el_list[i], prim_spectra_X = Prim_s[0], prim_spectra_y = Prim_s[1], x = np.arange(0, 30, 0.05), gauss_a = gaus )
        q = np.zeros(600)
        factor = 0 
        for j in range(i):
            q = q + np.array(material_mu(el_list[j], np.arange(0,30,0.05)*1000, XrfElement( el_list[j]).density,  kind = "total")* XrfElement( el_list[j]).density*0.5*n[i]*10**(-4)) 
            factor = factor + XrfElement( el_list[j]).density*n[i]*10**(-4)
        if i!=0:
            # plt.plot(  np.arange(0,30,0.05)   , prod_s*factor*(1 - np.exp(-q))/q )
            # plt.show()
            final_spectra = final_spectra + Narea(prod_s*factor*(1 - np.exp(-q))/q)*w
        else: 
            final_spectra = final_spectra + Narea(prod_s)*w

    air_z = np.random.random(1)
    factor = np.random.random_integers(5)
    q_air = np.array(material_mu("air",  np.arange(0,30,0.05)*1000 )*air_density*air_z*1000*factor)

    air_spectra = Narea(final_spectra* np.exp(-q_air))

    return air_spectra, peaks_pos, c  # c es reduced list con elementos 0s y 1s.  

def ind_trans_gen(N, Prim_s):
    """
    Simulate the transmission of X-rays through a single element and generate the transmitted spectrum after absorption.

    Only the absorption component is considered, and the photoelectric component is not used. The function
    returns only the transmitted spectrum, not the exciting spectrum.

    The list of proportions of the elements ('c') should contain all the elements, but most of them should have
    a proportion of 0 except for the specified element represented by the index 'N'.

    Args:
        N (int): The index of the element to simulate the transmission through.
        Prim_s (tuple): Tuple containing two arrays representing the primary peaks and their corresponding probabilities.
    
    Returns:
        tuple: A tuple containing three elements:
               - air_spectra (array): The transmitted spectrum after absorption through the specified element.
               - peaks_pos (array): A binary array indicating the presence of peaks in the spectrum.
               - c (array): A probability distribution representing the composition of the material.

    Note: The function simulates the absorption of X-rays through the specified element and computes the transmitted spectrum.
          It also considers the effect of air absorption in the final transmitted spectrum.
          The function relies on other helper functions like 'sum_prima' and 'material_mu'.
          The 'air_density' variable is assumed to be defined elsewhere in the code.
    """
    c = np.zeros(len(reduced_list))
    c[N]=1  
    el_list = []
    el_list.append(reduced_list[N]) 

    peaks_pos = np.zeros(len(peaks_dic))
    mask_lines =  [a[:len(reduced_list[N])]==reduced_list[N] for a in peaks_dic.keys()  ] #ponemos las lineas que tiene que haber.
    peaks_pos[np.where(mask_lines)[0]]=1

    gaus = np.random.uniform(low = 0.03 , high = 0.2  ) #0.05
    prod_s =  sum_prima(element = reduced_list[N], prim_spectra_X = Prim_s[0], prim_spectra_y = Prim_s[1], x = np.arange(0, 30, 0.05), gauss_a = gaus )

    air_z = np.random.random(1)
    factor = np.random.random_integers(5)
    q_air = np.array(material_mu("air",  np.arange(0,30,0.05)*1000 )*air_density*air_z*1000*factor)

    air_spectra =  Narea(prod_s*np.exp(-q_air))

    return air_spectra, peaks_pos, c  #la verdad que para lo que hace se podria omitir el ultimo calculo.

def pair_trans_gen(a, Prim_s ):
    """
    Simulate the transmission of X-rays through a material and generate the transmitted spectrum after absorption.

    Only the absorption component is considered, and the photoelectric component is not used. The function
    returns only the transmitted spectrum, not the exciting spectrum.

    The list of proportions of the elements ('a') should contain all the elements, but most of them should have
    a proportion of 0 except for some elements. The order of the elements should be randomized since they are 
    currently ordered by Z.

    Args:
        a (list): A list of element indices representing the material's composition.
        Prim_s (tuple): Tuple containing two arrays representing the primary peaks and their corresponding probabilities.

    Returns:
        tuple: A tuple containing three elements:
               - air_spectra (array): The transmitted spectrum after absorption through the material.
               - peaks_pos (array): A binary array indicating the presence of peaks in the spectrum.
               - c (array): A probability distribution representing the composition of the material.

    Note: The function simulates the absorption of X-rays through the material and computes the transmitted spectrum.
          It also considers the effect of air absorption in the final transmitted spectrum.
          The function relies on other helper functions like 'sum_prima' and 'material_mu'.
          The 'air_density' variable is assumed to be defined elsewhere in the code.
    """
    mask = [b not in a for b in np.arange(0,41,1)]
    c = np.random.random(len(reduced_list)) #/np.sum(c) para normalizar
    c = c/np.sum(c)
    c[mask]=0
    n = c[c> 0] 
    el_list = []
    peaks_pos = np.zeros(len(peaks_dic))
    for el in a:
        el_list.append(reduced_list[el]) 
        mask_lines =  [a[:len(reduced_list[el])]==reduced_list[el] for a in peaks_dic.keys()  ] #ponemos las lineas que tiene que haber.
        peaks_pos[np.where(mask_lines)[0]]=1

    posi = list(zip(*sorted(zip(a, np.arange(len(a))))))[1]
    n  = list(zip(*sorted(zip( n , posi))))[0]
    final_spectra = np.zeros(600)
    for i in range(len(el_list)-1, -1, -1): 
        gaus = np.random.uniform(low = 0.03 , high = 0.2  )
        w = n[i]
        # pos = a[i]
        prod_s = sum_prima(element = el_list[i], prim_spectra_X = Prim_s[0], prim_spectra_y = Prim_s[1], x = np.arange(0, 30, 0.05), gauss_a = gaus )        
        q = np.zeros(600)
        factor = 0 
        for j in range(i):
            q = q + np.array(material_mu(el_list[j], np.arange(0,30,0.05)*1000, XrfElement( el_list[j]).density,  kind = "photo")* XrfElement( el_list[j]).density*0.5*n[i]*10**(-4)) 
            factor = factor + XrfElement( el_list[j]).density*n[i]*10**(-4)

        if i!=0:
            # plt.plot(  np.arange(0,30,0.05)   , prod_s*factor*(1 - np.exp(-q))/q )
            # plt.show()
            final_spectra = final_spectra + Narea(prod_s*factor*(1 - np.exp(-q))/q)*w
        else: 
            final_spectra = final_spectra + Narea(prod_s)*w

    air_z = np.random.random(1)
    factor = np.random.random_integers(5)
    q_air = np.array(material_mu("air",  np.arange(0,30,0.05)*1000 )*air_density*air_z*1000*factor)

    air_spectra = Narea(final_spectra*np.exp(-q_air))
  
    return air_spectra, peaks_pos, c  

def Narea(array):
    """
    Normalize an array to create a probability distribution.

    The function takes an input array and normalizes it to create a probability distribution. 
    The normalization is performed by dividing each element of the array by its maximum value and then 
    dividing the resulting array by the sum of all elements.

    Args:
        array (array): The input array to be normalized.

    Returns:
        array: The normalized array representing a probability distribution.

    Note: The normalized array will have values between 0 and 1, and the sum of all elements in the 
          normalized array will be equal to 1, making it a probability distribution.
    """
    a = array/np.max(array) 
    return a/np.sum(a)

def escape_peaks(spectra): # he quitado c porque no lo he usado, podria usarlo para seleccionar solo algun pico de algun elemento.
    """
    Generate escape peaks given a histogram representing the spectra from which to add the escape peaks (spectra),
    the energy position of the peaks (peaks_pos), and the elements present in the spectra (c).

    Escape peaks are generated when the detector is excited by the X-ray radiation. Only the first line of Si 
    is considered (at 1.73 KeV).

    Args:
        spectra (array): A histogram representing the spectra from which escape peaks are to be added.

    Returns:
        f_spectra (array): The spectra with the escape peaks added.

    Note: This function simulates the creation of escape peaks for a histogram representing the spectra.
          Escape peaks are generated by taking the line of a peak (typically one of the largest peaks)
          and subtracting the Ka1 line of silicon at 1.73998 KeV to create a new peak with that energy.
          The probability of generating escape peaks can be related to the intensity and energy of the peaks.
    """
    #LA PROBABILIDAD DE QUE SE DE ESTO SERIA LA CROSS SECTION DE LA KA1 DEL SILICO POR EL PICO DE ENERGIA NO ????? 
    x = np.arange(0,30,0.05)
    area = 0.05 * np.sqrt(2 * np.pi)
    import scipy 
    peaks = scipy.signal.find_peaks(spectra, prominence = np.max(spectra)/15)
    prominences = sorted((zip(peaks[1]["prominences"], peaks[0])))
    proms = list(zip(*prominences))[0]
    # peaks_i = list(zip(*prominences))[1]
    N = round(0.6*len(proms)/2)
    f_spectra = spectra.copy()
    a = np.random.choice(range(round(len(proms)/2)), N , replace = False) 
   
    escape = np.around(np.array(proms),6)[np.argsort(-np.array(proms))[sorted(a)]]
    dictionary = dict( zip(np.around(peaks[1]["prominences"], 6), peaks[0]))
    for i in escape: 
        pos = dictionary[i]
        y_alt = spectra[pos]
        if x[pos] > 1.75:
            perc = np.random.randint(15)/100
            f_spectra -= gaussian(np.arange(0, 30, 0.05), area, x[pos], 0.05) * y_alt *perc
            f_spectra += gaussian(np.arange(0, 30, 0.05), np.sqrt(2 * np.pi)*0.1, x[pos]-1.73998, 0.1) * y_alt *perc

  
    return f_spectra

def sum_peaks(spectra):
    """
    Generate sum peaks given a histogram representing the spectra from which to add the escape peaks,
    the energy position of the peaks, and the elements present in the spectra.

    Sum peaks represent the situation when two photons arrive at the detector in a period of time 
    shorter than the detector resolution, hence summing their energies.

    Args:
        spectra (array): A histogram representing the spectra from which to add escape peaks.

    Returns:
        - f_spectra (array): The spectra with the sum peaks added.

    Note: This function simulates the creation of sum peaks by taking two peaks and adding them together.
          The prominence of the peaks is used to determine which peaks to select for summing.
          The function also applies random factors to control the intensity of the sum peaks.
    """
    x = np.arange(0,30,0.05)
    area = 0.05 * np.sqrt(2 * np.pi)
    import scipy 
    peaks = scipy.signal.find_peaks(spectra, prominence = np.max(spectra)/30) # dividinf factor must
    #be higher since we need at least double peaks in order to get a sum peak
    prominences = sorted((zip(peaks[1]["prominences"], peaks[0])))
    proms = list(zip(*prominences))[0]
    # peaks_i = list(zip(*prominences))[1]
    N = round(0.8*len(proms)/2) 
    f_spectra = spectra.copy()

    a = np.random.choice(range(round(len(proms)/2)), N , replace = False) # a son los picos que van a tener scape peaks.  # deberia de haber un minimo de dos picos para funcionar

    escape = np.around(np.array(proms),6)[np.argsort(-np.array(proms))[sorted(a)]]
    dictionary = dict( zip(np.around(peaks[1]["prominences"], 6), peaks[0]))
    # print(a, escape)
    if len(escape)>1: 
        # print("mas de dos picos")
        for i in range(len(escape)-1):
            # print("escape peak created") 
            pos1 = dictionary[escape[i]]
            pos2 = dictionary[escape[i+1]]
            y_alt = spectra[pos1]
            perc = np.random.randint(15)/100
            f_spectra -= gaussian(np.arange(0, 30, 0.05), area, x[pos1], 0.05) * y_alt *perc/2
            f_spectra -= gaussian(np.arange(0, 30, 0.05), area, x[pos2], 0.05) * y_alt *perc/2
            f_spectra += gaussian(np.arange(0, 30, 0.05), area, x[pos1] + x[pos2], 0.1) * y_alt *perc

    return f_spectra

def decalibration(spectra, params = []):
    """
    Simulate decalibration effects in a spectrum. The decalibration is mainly linear 
    with a small quadratic component. A spectrum for decalibration must be provided,
    and the parameters for the transformation are optional.

    Args:
        spectra (array): The spectrum to be decalibrated.
        params (list, optional): List of parameters [a, b, c] for the decalibration transformation.
                                 If not provided, random values within certain ranges will be used.

    Returns:
        tuple: A tuple containing two elements:
               - decalibrated_spectrum (array): The decalibrated spectrum after applying the transformation.
               - params (list): List of parameters [a, b, c] used for the decalibration transformation.

    Note: The decalibration transformation is represented as: x_tr = a + (1 + b) * x + c * x^2
          Where 'x' is the energy range, and 'a', 'b', and 'c' are the decalibration parameters.
          The function uses scipy's interp1d to perform the transformation.
    """
    from scipy.interpolate import interp1d
    x = np.arange(0,30,0.05)
    if params ==[]:
        a = np.random.uniform(low=-0.03, high=0.03)
        b = np.random.uniform(low=-0.03, high=0.03)
        c = np.random.uniform(low=-0.05, high=0.05)*10**(-3)
        params = [a,b,c]
    a = params[0]
    b = params[1]
    c = params[2]
    x_tr = a + (1+b)*x + c *x**2 
    decal = interp1d(x_tr, spectra, bounds_error= False, fill_value = 0 )
    return decal(x), [a,b,c]


copia_inter = interp1d(x_c, y_c, bounds_error = False, fill_value = 0 )
eff_inter = copia_inter(np.arange(0,30,0.05)) #modificar esto para que no sea un estandard

def detector_eff(spectra_y, spectra_x, alpha = "", beta = ""):
    """_Function that simulates the efficiency window of a detector. That is the loss of 
    counts due to the limited resolution of the x-ray detector window. For the moment per default the
    efficiency of the LABEC (INFN-FLorence) efficiency window is taken and multiplied by a sigmoid function 
    of parameters alpha and beta in order to modify slightly. _

    Args:
        spectra_y (_np.array_): _Y comonent of the Spectra _
        spectra_x (_np.array_): _X comonent of the Spectra _
        alpha (str, optional): _Alpha parameter of the sigma transformation. If not given it will be randomly generated_. Defaults to "".
        beta (str, optional): _Beta parameter of the sigma transformation. If not given it will be randomly generated _. Defaults to "".

    Raises:
        ValueError: _X and Y components of the spectra must have same dimension _

    Returns:
        _type_: _A new Y component of the spectra representin the spectra that has been passed by the detector._
    """
    try:
        np.testing.assert_array_equal(np.shape(spectra_x), np.shape(spectra_y))
        if alpha =="": 
            alpha = np.random.uniform(low = 0.01 , high = 40 )# de vez en cuando podria dar un uno y un 0, que es como no tener eficiencia. 
        if beta =="": 
            beta = np.random.uniform(low = 0.01 , high = 40)
        n = np.random.randint(50)
        new_eff = np.zeros(len(spectra_y))
        eff_inter = copia_inter(spectra_x)
        if n!=0: 
            print(np.shape(new_eff), np.shape(eff_inter))
            new_eff[n:] = eff_inter[:-n]
        else: 
            new_eff = eff_inter
        #y_c tendria que ser de la misma dimension que espectra es decir de 0 a 30, 600 bins.
        eff = sigmoid(new_eff, alpha,beta)
        return eff * spectra_y
    
    except AssertionError:
        raise ValueError("Arrays do not have the same dimensions.")
    

def sigmoid(x, a, b):
    """_Sigmoid function of a and b parameters_

    Args:
        x (_np.array_): _Array to apply the transformation to_
        a (_float_): _exponential parameter_
        b (_flaat_): _linear parameter_

    Returns:
        _type_: _description_
    """
    if type(x) != np.ndarray: 
        x = np.array(x)
    return 1/(1 + b*np.exp(-x*a)) 

def select_values(array, dictionary):
    """
    Select values and keys from a dictionary based on an array of conditions.

    Args:
        array (list): A list of values to act as conditions for selecting values and keys.
        dictionary (dict): A dictionary from which values and keys will be selected.

    Returns:
        tuple: A tuple containing two lists - selected_values and selected_keys.
               - selected_values (list): A list of values from the dictionary that correspond to the True elements in the 'array'.
               - selected_keys (list): A list of keys from the dictionary that correspond to the True elements in the 'array'.
    """
    mask = [value == 1 for value in array]
    selected_keys = [key for i, key in enumerate(dictionary.keys()) if mask[i]]
    selected_values = [value for i, value in enumerate(dictionary.values()) if mask[i]]
    
    return selected_values, selected_keys

def spectra_gen(a, Prim, brems,gauss_l = 0.17, s_counts = 30000,n_counts = 2000, b_counts = 3000, c_counts = 3000,plot = True,  escape = True, sum = True, decal = True, char_r = 15, brem_r = 5,noise_f = 1000, prop = "" ):
    """
    Generate a spectrum with various components based on input parameters.

    Args:
        a (str or list): Element(s) or spectrum to be processed. If it's a str, convert it to numerical values representing elements.
        Prim (tuple): Tuple containing two arrays representing primary peaks and their corresponding probabilities.
        brems (tuple): Tuple containing two arrays representing bremsstrahlung peaks and their corresponding probabilities.
        s_counts (int): Number of counts in the main spectrum.
        n_counts (int): Number of counts in the noise spectrum.
        b_counts (int): Number of counts in the bremsstrahlung spectrum.
        c_counts (int): Number of counts in the characteristic spectrum.
        plot (bool): If True, plot the generated spectrum using Bokeh.
        escape (bool): If True, apply escape peak correction to the spectrum.
        sum (bool): If True, sum the peaks in the spectrum.
        decal (bool): If True, apply decalibration to the spectrum.
        char_r (float): Characteristic peak range.
        brem_r (float): Bremsstrahlung peak range.
        noise_f (int): Factor to control the noise level in the spectrum.
        prop (float): Proportion parameter for adjusting the contribution of certain components.

    Returns:
        tuple: A tuple containing two elements:
               - final_d (array): The generated spectrum with various components combined.
               - params (dict): Dictionary containing parameters related to the generated spectrum.

    Note: Some functions like multi_trans_gen, escape_peaks, sum_peaks, decalibration, and detector_eff are assumed
          to be defined elsewhere and used in this function.
    """
    spec, peaks, els = multi_trans_gen( a, Prim, gauss_l)
    if escape == True: 
        spec = escape_peaks(spec)
    if sum == True:
        spec = sum_peaks(spec)
    if decal == True: 
        spec, params = decalibration(spec)
    spec = detector_eff(spec, np.arange(0,30,0.05))
    if prop == "":
        prop =  np.random.uniform()
    if (spec <0).any(): 
            spec[spec<0 ] = 0 

    brem = Narea(np.histogram(np.random.choice(brems[0], size = b_counts, p = Narea(brems[1])), bins = 600, range=(0.0,30))[0])
    char = Narea(np.histogram(np.random.choice(Prim[0], size = c_counts, p = Narea(Prim[1])), bins = 600, range=(0.0,30))[0])
    spec = Narea( np.histogram(np.random.choice(np.arange(0,30,0.05), size = s_counts, p = Narea(spec) ), bins = 600, range=(0.0,30))[0])
    noise = np.random.random(600)
    noise = Narea (np.histogram(np.random.choice(np.arange(0,30,0.05), size = n_counts, p = Narea(noise) ), bins = 600, range=(0.0,30))[0])
    final_d = ((brem/brem_r)*prop) + spec + noise/noise_f + ((char/char_r)*prop)
    if plot:
        from bokeh.plotting import figure, show
        from bokeh.models import HoverTool, ColumnDataSource
        from bokeh.io import output_notebook

        output_notebook()

        es, names = select_values(peaks, peaks_dic)
        box_indices = np.digitize(es, np.arange(0,30,0.05))-1 #counting starts at 0.
        xs = np.arange(0, 30, 0.05)[box_indices]
        ys = spec[box_indices]

        source = ColumnDataSource(data=dict(xs=xs, ys=ys, y0=np.zeros_like(es), names=names))
        # Create a figure object
        p = figure()

        # Add a line plot
        p.line(np.arange(0, 30, 0.05), final_d)

        # Add vertical lines with associated tooltips
        p.segment(x0='xs', y0='y0', x1='xs', y1='ys', line_color="green", source=source)
        hover = HoverTool(tooltips=[("Text", "@names")], renderers=[p.renderers[-1]])
        p.add_tools(hover)

        # Show the plot
        show(p)
    if decal == True: 
        return final_d, peaks, els , params
    else: 
        return final_d, peaks, els

# def plot_spectra(spec, c):
#     return 


###################################################################################################
###################################################################################################
# TORCH DATASET GENERATION 
# NO NEEED FOR THIS YOU CAN DIRECTLY IMPORT THE MODULE 
# def optional_gpu_function():
#     try:
#         import multiel_spectra.gpu_spectra as gpu_s
#         gpu_s.gpu_s()
#     except ImportError:
#         print("GPU functionality is not available. Please install the required packages and ensure a compatible GPU is available.")
# ##############################################################################################



#############################################################################################
# SPECTRA CREATION WITHOUT PARALLELIZATION 
###############################################################################################
#----------------------------------------------------------------------------------------------

# import os
# import sys
# import numpy as np
# import time
# import gc
# import argparse

# #ESTA NO ES LA VERSION EL PARALELO BUENA

# def create_spectra(Mode, save_path, input_arg=None, path_arg=None):
#     # Set the mode and path variables
#     import gc

#     save_path = save_path
    
#     physics = ["legacy", 'spekcalc','spekpy-v1', 'casim', 'kqp' ]   # Legacy physics mode rather than default (default: "default")
#     mu_source = ["pene", "nist"] # Penelope mu/mu_en data rather than NIST/XCOM (default: "nist")
#     Targets =  ["W", "Mo", "Rh"]
#     Prim, brems = Primary_gen(30, 46, 0.1, "casim", "nist", 1, 9, "Mo", [('Be',0.127),('Air',10)])


#     if Mode =="Ind": 
#         print("Individual Dataset creation")
#         print("Some other message")
        
#         train_size = 5000
#         decal = False
        
#         for i in range(train_size):
#             sys.stdout.write(f'\r{i} of {train_size}')
#             sys.stdout.flush()
            
#             # cada 3 decalibrar: 
#             if i%4==0: 
#                 decal = True 
#             else: 
#                 decal = False
#             if i%250: 
#                 k = np.random.randint(low = 20, high = 50)
#                 th = np.random.randint(low = 30, high = 60)
#                 be_width = np.random.uniform(low = 0, high = 0.4)
#                 air_width = np.random.uniform(low = 0, high = 15)
                # target_i =  np.random.randint(low = 0, high = 3)
                # mu_i = np.random.choice(range(2), None , replace = False)
                # if target_i > 0:
                #     phys_i = np.random.randint(low = 0 , high = 2)
                # else:
                #     phys_i = np.random.randint(low = 0 , high = len(physics))


#                 mas =  np.random.randint(low = 1, high = 20)
#                 f = np.random.randint(0,3)
#                 a = np.random.choice(range(3), f , replace = False)
#                 
#                 filters = [('Be',be_width),('Air',air_width)] 
#                 if len(a)> 0 :
#                     for p in a: 
#                         filters.append((extra_f[p], np.random.uniform(low = 0, high = 0.3) ))

#                 Prim, brems = Primary_gen(k, th, 0.1, physics[phys_i], mu_source[mu_i], 1, mas, Targets[target_i], filters)
        
#             for j in range(1, len(reduced_list) + 1):
#                 sys.stdout.write(f'\r{j} of 41')
#                 sys.stdout.flush()
#                 element = reduced_list[j-1]
#                 spec, peaks, els = ind_trans_gen(j-1, [Prim[0], Prim[1]], [brems[0], brems[1]])
#                 final_s = escape_peaks(spec, peaks, els)[0]
#                 final_s2 = sum_peaks(final_s, peaks, els)[0]
#                 #cada 3 veces decalibrar
#                 if decal == True: 
#                     final_s2 = decalibration(final_s2)

#                 final_d = detector_eff(final_s2)

#                 noise = np.random.random(600) / 1500
#                 if (final_d < 0).any(): 
#                     final_d[final_d < 0] = 0 
#                 brem = Narea(np.histogram(np.random.choice(brems[0], size = 30000, p = Narea(brems[1])), bins = 600, range=(0.0, 30))[0])
#                 new_spec = (brem / 5) * np.random.random(1) + Narea(np.histogram(np.random.choice(np.arange(0, 30, 0.05), size = 30000, p = Narea(final_d)), bins = 600, range=(0.0, 30))[0]) + noise 
#                 data = [new_spec, peaks, els]
#                 name =  "ind_" + element + "_" + str(i * 41 + j)
#                 np.save(save_path + name, data)

#                 del name, final_s, final_s2, final_d, brem, new_spec, data, noise
#                 del spec, peaks, els

#     elif Mode =="Pair":
        
#         train_size = 5000
#         decal = False

#         for i in range(128):
#             if i % 4 == 0: 
#                 decal = True 
#             else: 
#                 decal = False
#             if i % 10: 
#                 k = np.random.randint(low = 20, high = 50)
#                 th = np.random.randint(low = 30, high = 60)
#                 be_width = np.random.uniform(low = 0, high = 0.4)
#                 air_width = np.random.uniform(low = 0, high = 15)
#                 mu_i = np.random.choice(range(2), None , replace = False)
#                 phys_i = np.random.randint(low = 0 , high = len(physics))
#                 if (phys_i == 3) or (phys_i == 4): 
#                     target_i = np.random.choice(range(3), None , replace = False)
#                 else: 
#                     target_i = 0
#                 mas =  np.random.randint(low = 1, high = 20)
#                 f = np.random.randint(0, 3)
#                 b = np.random.choice(range(3), f , replace = False)
#                 extra_f = ["Al", "Cu", "Ti", "Ag"]
#                 filters = [('Be', be_width), ('Air', air_width)] 
#                 if len(b) > 0:
#                     for p in b: 
#                         filters.append((extra_f[p], np.random.uniform(low = 0, high = 0.3)))

#                 Prim, brems = Primary_gen(k, th, 0.1, physics[phys_i], mu_source[mu_i], 1, mas, Targets[target_i], filters)

#             for j in range(len(reduced_list)):
#                 element1 = reduced_list[j]
#                 for k in range(len(reduced_list)):
#                     element2 = reduced_list[k]

#                     spec, peaks, els = pair_trans_gen([Prim[0], Prim[1]], [brems[0], brems[1]])
#                     final_s = escape_peaks(spec, peaks, els)[0]
#                     final_s2 = sum_peaks(final_s, peaks, els)[0]
#                     if decal == True: 
#                         final_s2 = decalibration(final_s2)

#                     final_d = detector_eff(final_s2)
#                     noise = np.random.random(600) / 1500
#                     if (final_d < 0).any(): 
#                         final_d[final_d < 0] = 0 
#                     brem = Narea(np.histogram(np.random.choice(brems[0], size = 30000, p = Narea(brems[1])), bins = 600, range=(0.0, 30))[0])
#                     new_spec = (brem / 5) * np.random.random(1) + Narea(np.histogram(np.random.choice(np.arange(0, 30, 0.05), size = 30000, p = Narea(final_d)), bins = 600, range=(0.0, 30))[0]) + noise 
#                     data = [new_spec, peaks, els]
#                     name =  "pair_" + element1 + "_" + element2 + "_" + str(i)
#                     np.save(save_path + name, data)

#                     del name, final_s, final_s2, final_d, brem, new_spec, data, noise
#                     del spec, peaks, els

#     elif Mode =="Mix":
#         # revisar este que es el mas importante y aqui hay cosas raras
#         files = []
#         root = path_arg
#         veces = int(veces)
#         for r, d, f in os.walk(root):
#             for file in f:
#                 if '.npy' in file:
#                     files.append(os.path.join(r, file))
#         print("Files loaded")
#         for i in range(veces):
#             print(f'\r{i} of {veces}', end='', flush = True)
#             idx = np.random.choice(range(len(files)), 2, replace=False)
#             data1 = np.load(files[idx[0]], allow_pickle=True)
#             data2 = np.load(files[idx[1]], allow_pickle=True)
#             Spectra1 = data1[0]
#             Spectra2 = data2[0]
#             Elements = [data1[2], data2[2]]
#             spec_mix = Narea(Spectra1) + Narea(Spectra2)
#             peaks_mix = [data1[1], data2[1]]
#             final_s2 = decalibration(spec_mix)
#             final_d = detector_eff(final_s2)
#             noise = np.random.random(600) / 1500
#             if (final_d < 0).any(): 
#                 final_d[final_d < 0] = 0 
#             brem = Narea(np.histogram(np.random.choice(brems[0], size = 30000, p = Narea(brems[1])), bins = 600, range=(0.0, 30))[0])
#             new_spec = (brem / 5) * np.random.random(1) + Narea(np.histogram(np.random.choice(np.arange(0, 30, 0.05), size = 30000, p = Narea(final_d)), bins = 600, range=(0.0, 30))[0]) + noise 
#             data = [new_spec, peaks_mix, Elements]
#             name =  "mix_" + str(i)
#             np.save(save_path + name, data)

#             del name, final_s2, final_d, brem, new_spec, data, noise
#             del data1, data2, Spectra1, Spectra2, Elements, spec_mix, peaks_mix

#     else:
#         print('The script requires an input parameter, either: \n 1) Ind \n 2) Pair \n 3) Mix')
#         exit()

# # Test the function
# if __name__ == "__main__":
#     parser = argparse.ArgumentParser(description='Generate spectra data.')
#     parser.add_argument('--mode', type=str, required=True, help='Mode of operation: Ind, Pair, Mix')
#     parser.add_argument('--save_path', type=str, required=True, help='Path to save generated data')
#     parser.add_argument('--veces', type=int, required=True, help='Number of iterations or datasets to generate')
#     parser.add_argument('--input', type=str, help='Optional input argument')
#     parser.add_argument('--path_arg', type=str, help='Optional path argument')

#     args = parser.parse_args()
#     create_spectra(args.mode, args.save_path, args.veces, args.input, args.path_arg)
