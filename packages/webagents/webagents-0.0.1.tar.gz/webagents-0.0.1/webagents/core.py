# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_navigate.ipynb.

# %% auto 0
__all__ = ['start_browser', 'find_interactive_elements', 'perform_web_action']

# %% ../nbs/01_navigate.ipynb 3
from playwright.async_api import async_playwright, Browser, BrowserContext, Page, ElementHandle
from typing import Optional, Dict, Any, List
import asyncio

async def start_browser(
    url: str, #The URL to navigate to.
    browser_type: str = "chromium",  #The type of browser to use ('chromium', 'firefox', or 'webkit')
    headless: bool = True, # Whether to run the browser in headless mode.  
    timeout: int = 30000,  #Maximum navigation time in milliseconds. 
    viewport: Optional[Dict[str, int]] = None,  #Custom viewport size, e.g., {"width": 1280, "height": 720}.
    user_agent: Optional[str] = None, # Custom user agent string.
    extra_browser_args: Optional[list] = None, #  Additional browser arguments.
    context_options: Optional[Dict[str, Any]] = None # Additional context options.
) -> tuple[Browser, BrowserContext, Page]:  #browser, context, and page objects.
    
    """
    Launch a browser and navigate to a specified URL using Playwright.
    
    Raises: 
    
    `ValueError`: If an invalid browser type is specified. 
    
    `playwright.async_api.Error`: For Playwright-related errors.
    """
    playwright = await async_playwright().start()

    if browser_type == "chromium":
        browser_launch = playwright.chromium.launch
    elif browser_type == "firefox":
        browser_launch = playwright.firefox.launch
    elif browser_type == "webkit":
        browser_launch = playwright.webkit.launch
    else:
        raise ValueError(f"Invalid browser type: {browser_type}")

    browser_args = {"headless": headless}
    if extra_browser_args:
        browser_args["args"] = extra_browser_args

    browser = await browser_launch(**browser_args)

    context_args = {}
    if viewport:
        context_args["viewport"] = viewport
    if user_agent:
        context_args["user_agent"] = user_agent
    if context_options:
        context_args.update(context_options)

    context = await browser.new_context(**context_args)
    page = await context.new_page()

    await page.goto(url, timeout=timeout)

    return browser, context, page

# %% ../nbs/01_navigate.ipynb 5
async def find_interactive_elements(page: Page #The Playwright Page object representing the current web page.
                                   ) -> Dict[str, List[Dict[str, Any]]]: # A dictionary containing lists of interactive elements, categorized by element type.
    """
    Find all interactive elements on a webpage.
    """
    interactive_elements = {
        'links': [],
        'buttons': [],
        'inputs': [],
        'selects': [],
        'textareas': []
    }

    # Find links (a tags)
    links = await page.query_selector_all('a')
    for link in links:
        href = await link.get_attribute('href')
        text = await link.inner_text()
        interactive_elements['links'].append({
            'type': 'link',
            'href': href,
            'text': text
        })

    # Find buttons
    buttons = await page.query_selector_all('button')
    for button in buttons:
        text = await button.inner_text()
        interactive_elements['buttons'].append({
            'type': 'button',
            'text': text
        })

    # Find inputs
    inputs = await page.query_selector_all('input')
    for input_elem in inputs:
        input_type = await input_elem.get_attribute('type')
        name = await input_elem.get_attribute('name')
        value = await input_elem.get_attribute('value')
        interactive_elements['inputs'].append({
            'type': 'input',
            'input_type': input_type,
            'name': name,
            'value': value
        })

    # Find selects
    selects = await page.query_selector_all('select')
    for select in selects:
        name = await select.get_attribute('name')
        options = await select.query_selector_all('option')
        option_values = [await option.get_attribute('value') for option in options]
        interactive_elements['selects'].append({
            'type': 'select',
            'name': name,
            'options': option_values
        })

    # Find textareas
    textareas = await page.query_selector_all('textarea')
    for textarea in textareas:
        name = await textarea.get_attribute('name')
        value = await textarea.input_value()
        interactive_elements['textareas'].append({
            'type': 'textarea',
            'name': name,
            'value': value
        })

    return interactive_elements

# %% ../nbs/01_navigate.ipynb 7
async def perform_web_action(page: Page, #The Playwright Page object representing the current web page.
                             interactive_elements: Dict[str, List[Dict[str, Any]]], # The dictionary of interactive elements from find_interactive_elements.
                             action: str, # The action to perform ('click', 'input', 'select').
                             target: str, # The target element identifier (e.g., link text, button text, input name).
                             value: str = None #The value to input or select, if applicable.
                            ) -> None:
    """
    Perform an action on a web element based on user input.
     
    Raises a `ValueError` if the specified action or target is not valid.
    """
    if action not in ['click', 'input', 'select']:
        raise ValueError(f"Invalid action: {action}. Must be 'click', 'input', or 'select'.")

    if action == 'click':
        # Check links and buttons
        for link in interactive_elements['links']:
            if link['text'] == target or link['href'] == target:
                await page.click(f'a[href="{link["href"]}"]')
                return

        for button in interactive_elements['buttons']:
            if button['text'] == target:
                await page.click(f'button:has-text("{target}")')
                return

        for input_elem in interactive_elements['inputs']:
            if input_elem['name'] == target and input_elem['input_type'] == 'submit':
                await page.click(f'input[name="{target}"]')
                return

    elif action == 'input':
        for input_elem in interactive_elements['inputs']:
            if input_elem['name'] == target:
                await page.fill(f'input[name="{target}"]', value)
                print(f"Entered text in input: {target}")
                return

        for textarea in interactive_elements['textareas']:
            if textarea['name'] == target:
                await page.fill(f'textarea[name="{target}"]', value)
                return

    elif action == 'select':
        for select in interactive_elements['selects']:
            if select['name'] == target:
                if value in select['options']:
                    await page.select_option(f'select[name="{target}"]', value)
                    return
                else:
                    raise ValueError(f"Option '{value}' not found in select '{target}'")

    raise ValueError(f"Target '{target}' not found for action '{action}'")
