{
    "call_args": {
        "model": "claude-3-opus-20240229",
        "messages": [
            {
                "role": "system",
                "content": "Your job is to generate a plaintext plan to achieve the TASK described below.\nYou will be given a CODE CONTEXT to help you understand the problem.\nDo NOT write code, just return a plaintext plan.",
                "prompt_metadata": {
                    "name": "create_edit_plan",
                    "content": "Your job is to generate a plaintext plan to achieve the TASK described below.\nYou will be given a CODE CONTEXT to help you understand the problem.\nDo NOT write code, just return a plaintext plan.\n",
                    "context": {}
                }
            },
            {
                "role": "user",
                "content": "TASK: \npydicom should not define handler, formatter and log level.\nThe `config` module (imported when pydicom is imported) defines a handler and set the log level for the pydicom logger. This should not be the case IMO. It should be the responsibility of the client code of pydicom to configure the logging module to its convenience. Otherwise one end up having multiple logs record as soon as pydicom is imported:\n\nExample:\n```\nCould not import pillow\n2018-03-25 15:27:29,744 :: DEBUG :: pydicom \n  Could not import pillow\nCould not import jpeg_ls\n2018-03-25 15:27:29,745 :: DEBUG :: pydicom \n  Could not import jpeg_ls\nCould not import gdcm\n2018-03-25 15:27:29,745 :: DEBUG :: pydicom \n  Could not import gdcm\n``` \nOr am I missing something?\n\nCODE CONTEXT: pydicom/config.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Pydicom configuration options.\"\"\"\n3:\n4:# doc strings following items are picked up by sphinx for documentation\n5:\n6:import logging\n7:\n8:# Set the type used to hold DS values\n9:#    default False; was decimal-based in pydicom 0.9.7\n10:use_DS_decimal = False\n11:\n12:\n13:data_element_callback = None\n14:\"\"\"Set data_element_callback to a function to be called from read_dataset\n15:every time a RawDataElement has been returned, before it is added\n16:to the dataset.\n17:\"\"\"\n18:\n19:data_element_callback_kwargs = {}\n20:\"\"\"Set this to use as keyword arguments passed to the data_element_callback\n21:function\"\"\"\n22:\n23:\n24:def reset_data_element_callback():\n25:    global data_element_callback\n26:    global data_element_callback_kwargs\n27:    data_element_callback = None\n28:    data_element_callback_kwargs = {}\n29:\n30:\n31:def DS_decimal(use_Decimal_boolean=True):\n32:    \"\"\"Set DS class to be derived from Decimal (True) or from float (False)\n33:    If this function is never called, the default in pydicom >= 0.9.8\n34:    is for DS to be based on float.\n35:    \"\"\"\n36:    use_DS_decimal = use_Decimal_boolean\n37:    import pydicom.valuerep\n38:    if use_DS_decimal:\n39:        pydicom.valuerep.DSclass = pydicom.valuerep.DSdecimal\n40:    else:\n41:        pydicom.valuerep.DSclass = pydicom.valuerep.DSfloat\n42:\n43:\n44:# Configuration flags\n45:allow_DS_float = False\n46:\"\"\"Set allow_float to True to allow DSdecimal instances\n47:to be created with floats; otherwise, they must be explicitly\n48:converted to strings, with the user explicity setting the\n49:precision of digits and rounding. Default: False\"\"\"\n50:\n51:enforce_valid_values = False\n52:\"\"\"Raise errors if any value is not allowed by DICOM standard,\n53:e.g. DS strings that are longer than 16 characters;\n54:IS strings outside the allowed range.\n55:\"\"\"\n56:\n57:datetime_conversion = False\n58:\"\"\"Set datetime_conversion to convert DA, DT and TM\n59:data elements to datetime.date, datetime.datetime\n60:and datetime.time respectively. Default: False\n61:\"\"\"\n62:\n63:# Logging system and debug function to change logging level\n64:logger = logging.getLogger('pydicom')\n65:handler = logging.StreamHandler()\n66:formatter = logging.Formatter(\"%(message)s\")\n67:handler.setFormatter(formatter)\n68:logger.addHandler(handler)\n69:\n70:\n71:import pydicom.pixel_data_handlers.numpy_handler as np_handler  # noqa\n72:import pydicom.pixel_data_handlers.rle_handler as rle_handler  # noqa\n73:import pydicom.pixel_data_handlers.pillow_handler as pillow_handler  # noqa\n74:import pydicom.pixel_data_handlers.jpeg_ls_handler as jpegls_handler  # noqa\n75:import pydicom.pixel_data_handlers.gdcm_handler as gdcm_handler  # noqa\n76:\n77:pixel_data_handlers = [\n78:    np_handler,\n79:    rle_handler,\n80:    gdcm_handler,\n81:    pillow_handler,\n82:    jpegls_handler,\n83:]\n84:\"\"\"Handlers for converting (7fe0,0010) Pixel Data.\n85:This is an ordered list that the dataset.convert_pixel_data()\n86:method will try to extract a correctly sized numpy array from the\n87:PixelData element.\n88:\n89:Handers shall have two methods:\n90:\n91:def supports_transfer_syntax(ds)\n92:  This returns True if the handler might support the transfer syntax\n93:  indicated in the dicom_dataset\n94:\n95:def get_pixeldata(ds):\n96:  This shall either throw an exception or return a correctly sized numpy\n97:  array derived from the PixelData.  Reshaping the array to the correct\n98:  dimensions is handled outside the image handler\n99:\n100:The first handler that both announces that it supports the transfer syntax\n101:and does not throw an exception, either in getting the data or when the data\n102:is reshaped to the correct dimensions, is the handler that will provide the\n103:data.\n104:\n105:If they all fail, the last one to throw an exception gets to see its\n106:exception thrown up.\n107:\n108:If no one throws an exception, but they all refuse to support the transfer\n109:syntax, then this fact is announced in a NotImplementedError exception.\n110:\"\"\"\n111:\n112:\n113:def debug(debug_on=True):\n114:    \"\"\"Turn debugging of DICOM file reading and writing on or off.\n115:    When debugging is on, file location and details about the\n116:    elements read at that location are logged to the 'pydicom'\n117:    logger using python's logging module.\n118:\n119:    :param debug_on: True (default) to turn on debugging,\n120:    False to turn off.\n121:    \"\"\"\n122:    global logger, debugging\n123:    if debug_on:\n124:        logger.setLevel(logging.DEBUG)\n125:        debugging = True\n126:    else:\n127:        logger.setLevel(logging.WARNING)\n128:        debugging = False\n129:\n130:\n131:# force level=WARNING, in case logging default is set differently (issue 103)\n132:debug(False)\n\ndicom.py\n1:msg = \"\"\"\n2:Pydicom via 'import dicom' has been removed in pydicom version 1.0.\n3:Please install the `dicom` package to restore function of code relying\n4:on pydicom 0.9.9 or earlier. E.g. `pip install dicom`.\n5:Alternatively, most code can easily be converted to pydicom > 1.0 by\n6:changing import lines from 'import dicom' to 'import pydicom'.\n7:See the Transition Guide at\n8:https://pydicom.github.io/pydicom/stable/transition_to_pydicom1.html.\n9:\"\"\"\n10:\n11:raise ImportError(msg)\n\npydicom/util/__init__.py\n\npydicom/pixel_data_handlers/pillow_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Use the pillow python package to decode pixel transfer syntaxes.\"\"\"\n3:\n4:import io\n5:import logging\n6:\n7:try:\n8:    import numpy\n9:    HAVE_NP = True\n10:except ImportError:\n11:    HAVE_NP = False\n12:\n13:try:\n14:    from PIL import Image\n15:    HAVE_PIL = True\n16:except ImportError:\n17:    HAVE_PIL = False\n18:\n19:try:\n20:    from PIL import _imaging\n21:    HAVE_JPEG = getattr(_imaging, \"jpeg_decoder\", False)\n22:    HAVE_JPEG2K = getattr(_imaging, \"jpeg2k_decoder\", False)\n23:except ImportError:\n24:    HAVE_JPEG = False\n25:    HAVE_JPEG2K = False\n26:\n27:import pydicom.encaps\n28:from pydicom.pixel_data_handlers.util import dtype_corrected_for_endianness\n29:import pydicom.uid\n30:\n31:\n32:logger = logging.getLogger('pydicom')\n33:\n34:PillowSupportedTransferSyntaxes = [\n35:    pydicom.uid.JPEGBaseline,\n36:    pydicom.uid.JPEGLossless,\n37:    pydicom.uid.JPEGExtended,\n38:    pydicom.uid.JPEG2000Lossless,\n39:]\n40:PillowJPEG2000TransferSyntaxes = [\n41:    pydicom.uid.JPEG2000Lossless,\n42:]\n43:PillowJPEGTransferSyntaxes = [\n44:    pydicom.uid.JPEGBaseline,\n45:    pydicom.uid.JPEGExtended,\n46:]\n47:\n48:HANDLER_NAME = 'Pillow'\n49:\n50:DEPENDENCIES = {\n51:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n52:    'PIL': ('https://python-pillow.org/', 'Pillow'),\n53:}\n54:\n55:\n56:def is_available():\n57:    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n58:    return HAVE_NP and HAVE_PIL\n59:\n...\n150:    numpy_format = dtype_corrected_for_endianness(\n151:        dicom_dataset.is_little_endian, numpy_format)\n152:\n153:    # decompress here\n154:    if transfer_syntax in PillowJPEGTransferSyntaxes:\n155:        logger.debug(\"This is a JPEG lossy format\")\n156:        if dicom_dataset.BitsAllocated > 8:\n157:            raise NotImplementedError(\"JPEG Lossy only supported if \"\n158:                                      \"Bits Allocated = 8\")\n159:        generic_jpeg_file_header = b''\n160:        frame_start_from = 0\n161:    elif transfer_syntax in PillowJPEG2000TransferSyntaxes:\n162:        logger.debug(\"This is a JPEG 2000 format\")\n163:        generic_jpeg_file_header = b''\n164:        # generic_jpeg_file_header = b'\\x00\\x00\\x00\\x0C\\x6A'\n165:        #     b'\\x50\\x20\\x20\\x0D\\x0A\\x87\\x0A'\n166:        frame_start_from = 0\n167:    else:\n168:        logger.debug(\"This is a another pillow supported format\")\n169:        generic_jpeg_file_header = b''\n170:        frame_start_from = 0\n171:\n172:    try:\n173:        UncompressedPixelData = bytearray()\n174:        if ('NumberOfFrames' in dicom_dataset and\n175:                dicom_dataset.NumberOfFrames > 1):\n176:            # multiple compressed frames\n177:            CompressedPixelDataSeq = \\\n178:                pydicom.encaps.decode_data_sequence(\n179:                    dicom_dataset.PixelData)\n...\n\npydicom/__init__.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"pydicom package -- easily handle DICOM files.\n3:   See Quick Start below.\n4:\n5:-----------\n6:Quick Start\n7:-----------\n8:\n9:1. A simple program to read a dicom file, modify a value, and write to a new\n10:   file::\n11:\n12:    from pydicom.filereader import dcmread\n13:    dataset = dcmread(\"file1.dcm\")\n14:    dataset.PatientName = 'anonymous'\n15:    dataset.save_as(\"file2.dcm\")\n16:\n17:2. See the files in the examples directory that came with this package for more\n18:   examples, including some interactive sessions.\n19:\n20:3. Learn the methods of the Dataset class; that is the one you will work with\n21:   most directly.\n22:\n23:4. Questions and comments can be directed to the pydicom google group:\n24:   http://groups.google.com/group/pydicom\n25:\n26:5. Bugs and other issues can be reported in the issue tracker:\n27:   https://www.github.com/pydicom/pydicom\n28:\n29:\"\"\"\n30:\n31:\n32:from pydicom.dataelem import DataElement\n33:from pydicom.dataset import Dataset, FileDataset\n34:from pydicom.filereader import dcmread, read_file\n35:from pydicom.filewriter import dcmwrite, write_file\n36:from pydicom.sequence import Sequence\n37:\n38:from ._version import __version__, __version_info__\n39:\n40:__all__ = ['DataElement',\n41:           'Dataset',\n42:           'FileDataset',\n43:           'Sequence',\n44:           'dcmread',\n45:           'dcmwrite',\n46:           'read_file',\n47:           'write_file',\n48:           '__version__',\n49:           '__version_info__']\n50:\n51:from pydicom.compat import in_py2\n52:if in_py2:\n53:    import warnings\n54:    msg = 'Python 2 will no longer be supported after the pydicom v1.4 release'\n55:    warnings.warn(msg, DeprecationWarning)\n\npydicom/pixel_data_handlers/__init__.py\n\npydicom/pixel_data_handlers/jpeg_ls_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"\n3:Use the jpeg_ls (CharPyLS) python package to decode pixel transfer syntaxes.\n4:\"\"\"\n5:\n6:try:\n7:    import numpy\n8:    HAVE_NP = True\n9:except ImportError:\n10:    HAVE_NP = False\n11:\n12:try:\n13:    import jpeg_ls\n14:    HAVE_JPEGLS = True\n15:except ImportError:\n16:    HAVE_JPEGLS = False\n17:\n18:import pydicom.encaps\n19:from pydicom.pixel_data_handlers.util import dtype_corrected_for_endianness\n20:import pydicom.uid\n21:\n22:\n23:HANDLER_NAME = 'JPEG-LS'\n24:\n25:DEPENDENCIES = {\n26:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n27:    'jpeg_ls': ('https://github.com/Who8MyLunch/CharPyLS', 'CharPyLS'),\n28:}\n29:\n...\n\npydicom/tests/__init__.py\n\ndoc/getting_started.rst\n1:.. _getting_started:\n2:\n3:============================\n4:Getting Started with pydicom\n5:============================\n6:\n7:.. rubric:: Brief overview of pydicom and how to install.\n8:\n9:\n10:Introduction\n11:============\n12:\n13:Pydicom is a pure Python package for working with `DICOM\n14:<http://en.wikipedia.org/wiki/DICOM>`_ files such as medical images, reports,\n15:and radiotherapy objects.\n16:\n17:Pydicom makes it easy to read these complex files into natural pythonic\n18:structures for easy manipulation. Modified datasets can be written again to\n19:DICOM format files.\n20:\n21:Here is a simple example of using pydicom in an interactive session, to read a\n22:radiotherapy plan file, change the patient setup from head-first-supine to\n23:head-first-prone, and save to a new file::\n24:\n25:  >>> import os\n26:  >>> import pydicom\n27:  >>> from pydicom.data import get_testdata_files\n28:  >>> filename = get_testdata_files(\"rtplan.dcm\")[0]\n29:  >>> ds = pydicom.dcmread(filename)  # plan dataset\n30:  >>> ds.PatientName\n31:  'Last^First^mid^pre'\n32:  >>> ds.dir(\"setup\")    # get a list of tags with \"setup\" somewhere in the name\n33:  ['PatientSetupSequence']\n34:  >>> ds.PatientSetupSequence[0]\n35:  (0018, 5100) Patient Position                    CS: 'HFS'\n36:  (300a, 0182) Patient Setup Number                IS: '1'\n37:  (300a, 01b2) Setup Technique Description         ST: ''\n38:  >>> ds.PatientSetupSequence[0].PatientPosition = \"HFP\"\n39:  >>> ds.save_as(\"rtplan2.dcm\")\n40:\n41:..\n42:  >>> os.remove(\"rtplan2.dcm\")\n43:\n44:Pydicom is not a DICOM server [#]_, and is not primarily about viewing\n45:images. It is designed to let you manipulate data elements in DICOM files with\n46:Python code.\n47:\n48:Pydicom is easy to install and use, and because it is a pure Python package, it\n49:should run wherever Python runs.\n50:\n51:One limitation of pydicom: compressed pixel data (e.g. JPEG) can only be\n52:altered in an intelligent way if :doc:`decompressing </image_data_handlers>`\n53:them first. Once decompressed, they can be altered and written back to a\n54:DICOM file the same way as initially uncompressed data.\n55:\n56:License\n57:=======\n58:\n59:Pydicom has an MIT-based `license\n60:<https://github.com/pydicom/pydicom/blob/master/LICENSE>`_.\n61:\n62:Installing\n63:==========\n64:\n65:As a pure Python package, pydicom is easy to install and has no requirements\n66:other than Python itself (the NumPy library is recommended, but is only\n67:required if manipulating pixel data).\n68:\n69:\n70:Prerequisites\n71:-------------\n72:\n73:* Python 2.7, 3.4 or later\n74:* Optional dependencies:\n75:   * numpy\n76:   * pillow\n77:   * gdcm\n78:   * jpeg_ls\n79:   * jpeg2000\n80:   * pytest (if running pydicom's test suite). pytest<5 if in Python 2.\n81:\n82:\n83:Installing pydicom\n84:------------------\n85:\n86:Pydicom is currently available on `PyPi <https://pypi.python.org/pypi/pydicom/>`_\n87:. The simplest way to install pydicom alone is using ``pip`` at a command line::\n88:\n89:  pip install -U pydicom\n90:\n91:which installs the latest release.  To install the latest code from the repository\n92:(usually stable, but may have undocumented changes or bugs)::\n93:\n94:  pip install -U git+https://github.com/pydicom/pydicom.git\n95:\n96:\n97:Pydicom is also available on conda-forge::\n98:\n99:  conda install pydicom --channel conda-forge\n100:\n101:To install pydicom along with image handlers for compressed pixel data, \n102:we encourage you to use `Miniconda <https://conda.io/miniconda.html>`_ or\n103:`Anaconda <https://docs.continuum.io/anaconda/>`_.  For example::\n104:\n105:  conda create --name pydicomenv python=3.6 pip numpy\n106:  conda install pydicom --channel conda-forge\n107:\n108:will install pip, pydicom, and numpy in an environment called pydicomenv.  \n109:To add gdcm after activating the environment::\n110:\n111:  conda install -c conda-forge gdcm\n112:\n113:The environment is optional; see the conda software for details of its setup \n114:and use of environments.\n115:\n116:For developers, you can clone the pydicom repository and run \n117:the ``setup.py`` file. Use the following commands to get a copy \n118:from GitHub and install all dependencies::\n119:\n120:  git clone https://github.com/pydicom/pydicom.git\n121:  cd pydicom\n122:  pip install .\n123:\n124:or, for the last line, instead use::\n125:\n126:  pip install -e .\n127:\n128:to install in 'develop' or 'editable' mode, where changes can be made to the\n129:local working code and Python will use the updated pydicom code.\n130:\n131:\n132:Test and coverage\n133:=================\n134:\n135:To test the installed code on any platform, change to the directory of \n136:pydicom's setup.py file and::\n137:\n138:  python setup.py test\n139:\n140:This will install `pytest <https://pytest.org>`_ if it is not \n141:already installed.\n142:\n143:In v1.3 run under Python 2, if pytest is not found, please `python2 -m pip install \"pytest<5\"`\n144:  \n145:Or, in linux you can also use::\n146:\n147:  make test-code\n148:\n149:To test the coverage of your versions in linux::\n150:\n151:  make test-coverage\n152:\n153:\n154:Using pydicom\n155:=============\n156:\n157:Once installed, the package can be imported at a Python command line or used\n158:in your own Python program with ``import pydicom``.\n159:See the `examples directory\n160:<https://github.com/pydicom/pydicom/tree/master/examples>`_\n161:for both kinds of uses. Also see the :doc:`User Guide </pydicom_user_guide>`\n162:for more details of how to use the package.\n163:\n164:Support\n165:=======\n166:\n167:Please join the `pydicom discussion group\n168:<http://groups.google.com/group/pydicom>`_ to ask questions or give feedback.\n169:Bugs can be submitted through the `issue tracker\n170:<https://github.com/pydicom/pydicom/issues>`_.  Besides the example directory,\n171:cookbook recipes are encouraged to be posted on the `wiki page\n172:<https://github.com/pydicom/pydicom/wiki>`_.\n173:\n174:New versions, major bug fixes, etc. will also be announced through the group.\n175:\n176:Next Steps\n177:==========\n178:\n179:To start learning how to use pydicom, see the :doc:`pydicom_user_guide`.\n180:\n181:.. rubric:: Footnotes::\n182:\n183:.. [#] For DICOM network capabilities, see the\n184:   `pynetdicom <https://github.com/patmun/pynetdicom>`_ and the newer\n185:   `pynetdicom3 <https://github.com/pydicom/pynetdicom3>`_ projects.\n186:.. [#] If using python(x,y), other packages you might be interested in include IPython\n187:   (an indispensable interactive shell with auto-completion, history etc),\n188:   NumPy (optionally used by pydicom for pixel data), and ITK/VTK or PIL\n189:   (image processing and visualization).\n\npydicom/pixel_data_handlers/gdcm_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Use the gdcm python package to decode pixel transfer syntaxes.\"\"\"\n3:\n4:import sys\n5:\n6:try:\n7:    import numpy\n8:    HAVE_NP = True\n9:except ImportError:\n10:    HAVE_NP = False\n11:\n12:try:\n13:    import gdcm\n14:    HAVE_GDCM = True\n15:    HAVE_GDCM_IN_MEMORY_SUPPORT = hasattr(gdcm.DataElement,\n16:                                          'SetByteStringValue')\n17:except ImportError:\n18:    HAVE_GDCM = False\n19:    HAVE_GDCM_IN_MEMORY_SUPPORT = False\n20:\n21:import pydicom.uid\n22:from pydicom import compat\n23:from pydicom.pixel_data_handlers.util import get_expected_length, pixel_dtype\n24:\n25:\n26:HANDLER_NAME = 'GDCM'\n27:\n28:DEPENDENCIES = {\n29:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n...\n\npydicom/tests/test_pillow_pixel_data.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\n3:import os\n4:import sys\n5:\n6:import pytest\n7:\n8:import pydicom\n9:from pydicom.filereader import dcmread\n10:from pydicom.data import get_testdata_files\n11:from pydicom.tag import Tag\n12:\n13:# Python 3.4 pytest does not have pytest.param?\n14:have_pytest_param = hasattr(pytest, 'param')\n15:\n16:try:\n17:    from pydicom.pixel_data_handlers import numpy_handler\n18:    HAVE_NP = numpy_handler.HAVE_NP\n19:except ImportError:\n20:    HAVE_NP = False\n21:    numpy_handler = None\n22:\n23:try:\n24:    from pydicom.pixel_data_handlers import pillow_handler\n25:    HAVE_PIL = pillow_handler.HAVE_PIL\n26:    HAVE_JPEG = pillow_handler.HAVE_JPEG\n27:    HAVE_JPEG2K = pillow_handler.HAVE_JPEG2K\n28:    import numpy as np\n29:except ImportError:\n30:    pillow_handler = None\n31:    HAVE_PIL = False\n32:    HAVE_JPEG = False\n33:    HAVE_JPEG2K = False\n34:\n35:\n36:pillow_missing_message = (\"pillow is not available \"\n37:                          \"in this test environment\")\n38:\n39:TEST_PIL = HAVE_NP and HAVE_PIL\n40:TEST_JPEG = TEST_PIL and HAVE_JPEG\n41:TEST_JPEG2K = TEST_PIL and HAVE_JPEG2K\n42:\n43:empty_number_tags_name = get_testdata_files(\n44:    \"reportsi_with_empty_number_tags.dcm\")[0]\n45:rtplan_name = get_testdata_files(\"rtplan.dcm\")[0]\n46:rtdose_name = get_testdata_files(\"rtdose.dcm\")[0]\n47:ct_name = get_testdata_files(\"CT_small.dcm\")[0]\n48:mr_name = get_testdata_files(\"MR_small.dcm\")[0]\n49:truncated_mr_name = get_testdata_files(\"MR_truncated.dcm\")[0]\n50:jpeg2000_name = get_testdata_files(\"JPEG2000.dcm\")[0]\n51:jpeg2000_lossless_name = get_testdata_files(\n52:    \"MR_small_jp2klossless.dcm\")[0]\n53:jpeg_ls_lossless_name = get_testdata_files(\n54:    \"MR_small_jpeg_ls_lossless.dcm\")[0]\n55:jpeg_lossy_name = get_testdata_files(\"JPEG-lossy.dcm\")[0]\n56:jpeg_lossless_name = get_testdata_files(\"JPEG-LL.dcm\")[0]\n57:deflate_name = get_testdata_files(\"image_dfl.dcm\")[0]\n58:rtstruct_name = get_testdata_files(\"rtstruct.dcm\")[0]\n59:priv_SQ_name = get_testdata_files(\"priv_SQ.dcm\")[0]\n...\n\ndoc/transition_to_pydicom1.rst\n1:.. _transition_to_pydicom1:\n2:\n3:Transition to pydicom 1.x\n4:=========================\n5:\n6:.. rubric:: Important information on differences in pydicom post 1.0 vs pre-1.0\n7:\n8:Introduction\n9:------------\n10:\n11:As is often the case for major software version number changes, pydicom 1.0\n12:breaks with the previous release of pydicom (0.9.9) in several ways.  These\n13:require changes to user code to target the pydicom >= 1.0 package, or to check\n14:and deal with the differences between the versions.\n15:\n16:Backwards-incompatible changes post 1.0\n17:\n18:  * the library is no longer ``dicom`` but is ``pydicom``, to match the package\n19:    name\n20:  * short-form names such as ``Beams`` are no longer allowed; use the full\n21:    keyword e.g. ``BeamSequence``\n22:  * some less-used modules within pydicom have been renamed, e.g. ``dicom.UID``\n23:    is now ``pydicom.uid``\n24:\n25:Why was the package name changed?  There are several reasons for this change:\n26:\n27:  * it is standard Python practice for the package and the installed library to\n28:    have the same name\n29:  * first-time users expect to be able to type ``import pydicom`` rather than\n30:    ``import dicom``, which has caused confusion\n31:  * it makes sense for search engines - with the correct name it is much easier\n32:    to find relevant questions and example code online\n33:\n34:The decision wasn't taken lightly, but with a great deal of discussion on the\n35:GitHub issues list.  Having made the leap, the rest of this guide should help\n36:smooth the way...\n37:\n38:For authors of packages requiring pydicom < 1.0\n39:-----------------------------------------------\n40:\n41:The old pydicom releases have been split off into their own package, called\n42:``dicom``, which is now hosted on PyPI. This allows the old library ``dicom``\n43:to co-exist alongside the new library ``pydicom``.\n44:\n45:The main things to do, to ensure your old pydicom code will remain functional,\n46:are:\n47:\n48:   (a) you should ``pip uninstall pydicom`` and ``pip install dicom`` in your\n49:       existing pydicom installs\n50:   (b) If you have ``requirements.txt`` files, change the pydicom line from\n51:       \"pydicom\" to \"dicom\" e.g.  ``pydicom==0.9.9`` becomes ``dicom==0.9.9``\n52:   (c) Change your instructions to users to ``pip install dicom`` rather than\n53:       ``pip install pydicom``\n54:\n55:\n56:Error messages relating to the pydicom transition\n57:-------------------------------------------------\n58:\n59:This section is here in the hopes of people getting directed to this page on\n60:searches. If that's you, then welcome! Hopefully the information here can get\n61:things going quickly for you.\n62:\n63:For those with pydicom < 1.0 installed, on trying to import pydicom, they will\n64:get an ImportError message::\n65:\n66:  >>> import pydicom # doctest: +SKIP\n67:  Traceback (most recent call last):\n68:    File \"<stdin>\", line 1, in <module>\n69:  ImportError: No module named pydicom\n70:\n71:Your choice then is to update to pydicom >=1.0 (see Installing pydicom\n72:section), or to instead use ``import dicom`` and follow the old-style pydicom\n73:syntax.\n74:\n75:Conversely, if pydicom >= 1.0 is installed, the error message for ``import\n76:dicom`` will look like::\n77:\n78:  >>> import dicom # doctest: +SKIP\n79:  Traceback (most recent call last):\n80:    File \"<stdin>\", line 1, in <module>\n81:  ImportError: No module named dicom\n82:\n83:In this case you likely have installed pydicom >= 1.0, and so the ``dicom`` library\n84:does not exist.  You can simply ``import pydicom`` instead, and continue with\n85:the new pydicom, or, if you really need the old pydicom, then you should::\n86:\n87:  pip install dicom\n88:\n89:and you should be good to go.\n90:\n91:\n92:API Changes in version 1.0\n93:==========================\n94:\n95:Apart from the change of the package name, there are some changes in\n96:module names, class names, and behavior that may require some code changes.\n97:\n98:Changed module names\n99:--------------------\n100:\n101:  * module ``UID`` is now ``uid``\n102:\n103:Changed function and variable names\n104:-----------------------------------\n105:\n106:  * in module ``datadict``:\n107:\n108:    * ``dictionaryVM()`` -> ``dictionary_VM``\n109:    * ``dictionaryVR()`` -> ``dictionary_VR``\n110:    * ``private_dictionaryVM()`` -> ``private_dictionary_VM``\n111:    * ``private_dictionaryVR()`` -> ``private_dictionary_VR``\n112:  * in module ``filereader``:\n113:\n114:    * ``read_file()`` -> ``dcmread()`` (but old name remains for compatibility)\n115:  * in module ``filewriter``:\n116:\n117:    * ``write_file()`` -> ``dcmwrite()`` (but old name remains for compatibility)\n118:  * module ``tagtools``:\n119:\n120:    * ``tag_in_exception()`` has been moved to ``tag`` module\n121:  * module ``uid``:\n122:\n123:    * ``UID.is_valid()`` is now a property\n124:    * ``NotCompressedPixelTransferSyntaxes`` ->  ``UncompressedPixelTransferSyntaxes``\n125:    * ``pydicom_root_UID`` -> ``PYDICOM_ROOT_UID``\n126:\n127:Removed functions and names\n128:---------------------------\n129:\n130:  * support for old names (before DICOM keywords) in module ``datadict`` is\n131:    gone (``CleanName()``, ``short_name()``, ``long_name()``,\n132:    ``all_names_for_tag()``\n133:  * ``filereader.not_group2()`` is no longer available\n134:  * ``uid.pydicom_UIDs`` has been removed\n135:\n136:Changed behavior\n137:----------------\n138:\n139:  * ``dataset.save_as()``:  ``TransferSyntaxUID`` not added automatically to ``dataset.file_meta`` if\n140:    missing\n\npydicom/dataset.py\n...\n1260:                missing = [dd for dd in hh_deps if have_package(dd) is None]\n1261:                # Package names\n1262:                names = [hh_deps[name][1] for name in missing]\n1263:                pkg_msg.append(\n1264:                    \"{} (req. {})\"\n1265:                    .format(hh.HANDLER_NAME, ', '.join(names))\n1266:                )\n1267:\n1268:            raise RuntimeError(msg + ', '.join(pkg_msg))\n1269:\n1270:        last_exception = None\n1271:        for handler in available_handlers:\n1272:            try:\n1273:                # Use the handler to get a 1D numpy array of the pixel data\n1274:                arr = handler.get_pixeldata(self)\n1275:                self._pixel_array = reshape_pixel_array(self, arr)\n1276:\n1277:                # Some handler/transfer syntax combinations may need to\n1278:                #   convert the color space from YCbCr to RGB\n1279:                if handler.needs_to_convert_to_RGB(self):\n1280:                    self._pixel_array = convert_color_space(self._pixel_array,\n1281:                                                            'YBR_FULL',\n1282:                                                            'RGB')\n1283:\n1284:                self._pixel_id = id(self.PixelData)\n1285:\n1286:                return\n1287:            except Exception as exc:\n1288:                logger.debug(\n1289:                    \"Exception raised by pixel data handler\", exc_info=exc\n...\n",
                "prompt_metadata": {
                    "name": "create_edit_plan_user",
                    "content": "TASK: {{ task }}\n\nCODE CONTEXT: {{ context }}\n",
                    "context": {
                        "task": "\npydicom should not define handler, formatter and log level.\nThe `config` module (imported when pydicom is imported) defines a handler and set the log level for the pydicom logger. This should not be the case IMO. It should be the responsibility of the client code of pydicom to configure the logging module to its convenience. Otherwise one end up having multiple logs record as soon as pydicom is imported:\n\nExample:\n```\nCould not import pillow\n2018-03-25 15:27:29,744 :: DEBUG :: pydicom \n  Could not import pillow\nCould not import jpeg_ls\n2018-03-25 15:27:29,745 :: DEBUG :: pydicom \n  Could not import jpeg_ls\nCould not import gdcm\n2018-03-25 15:27:29,745 :: DEBUG :: pydicom \n  Could not import gdcm\n``` \nOr am I missing something?",
                        "context": "pydicom/config.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Pydicom configuration options.\"\"\"\n3:\n4:# doc strings following items are picked up by sphinx for documentation\n5:\n6:import logging\n7:\n8:# Set the type used to hold DS values\n9:#    default False; was decimal-based in pydicom 0.9.7\n10:use_DS_decimal = False\n11:\n12:\n13:data_element_callback = None\n14:\"\"\"Set data_element_callback to a function to be called from read_dataset\n15:every time a RawDataElement has been returned, before it is added\n16:to the dataset.\n17:\"\"\"\n18:\n19:data_element_callback_kwargs = {}\n20:\"\"\"Set this to use as keyword arguments passed to the data_element_callback\n21:function\"\"\"\n22:\n23:\n24:def reset_data_element_callback():\n25:    global data_element_callback\n26:    global data_element_callback_kwargs\n27:    data_element_callback = None\n28:    data_element_callback_kwargs = {}\n29:\n30:\n31:def DS_decimal(use_Decimal_boolean=True):\n32:    \"\"\"Set DS class to be derived from Decimal (True) or from float (False)\n33:    If this function is never called, the default in pydicom >= 0.9.8\n34:    is for DS to be based on float.\n35:    \"\"\"\n36:    use_DS_decimal = use_Decimal_boolean\n37:    import pydicom.valuerep\n38:    if use_DS_decimal:\n39:        pydicom.valuerep.DSclass = pydicom.valuerep.DSdecimal\n40:    else:\n41:        pydicom.valuerep.DSclass = pydicom.valuerep.DSfloat\n42:\n43:\n44:# Configuration flags\n45:allow_DS_float = False\n46:\"\"\"Set allow_float to True to allow DSdecimal instances\n47:to be created with floats; otherwise, they must be explicitly\n48:converted to strings, with the user explicity setting the\n49:precision of digits and rounding. Default: False\"\"\"\n50:\n51:enforce_valid_values = False\n52:\"\"\"Raise errors if any value is not allowed by DICOM standard,\n53:e.g. DS strings that are longer than 16 characters;\n54:IS strings outside the allowed range.\n55:\"\"\"\n56:\n57:datetime_conversion = False\n58:\"\"\"Set datetime_conversion to convert DA, DT and TM\n59:data elements to datetime.date, datetime.datetime\n60:and datetime.time respectively. Default: False\n61:\"\"\"\n62:\n63:# Logging system and debug function to change logging level\n64:logger = logging.getLogger('pydicom')\n65:handler = logging.StreamHandler()\n66:formatter = logging.Formatter(\"%(message)s\")\n67:handler.setFormatter(formatter)\n68:logger.addHandler(handler)\n69:\n70:\n71:import pydicom.pixel_data_handlers.numpy_handler as np_handler  # noqa\n72:import pydicom.pixel_data_handlers.rle_handler as rle_handler  # noqa\n73:import pydicom.pixel_data_handlers.pillow_handler as pillow_handler  # noqa\n74:import pydicom.pixel_data_handlers.jpeg_ls_handler as jpegls_handler  # noqa\n75:import pydicom.pixel_data_handlers.gdcm_handler as gdcm_handler  # noqa\n76:\n77:pixel_data_handlers = [\n78:    np_handler,\n79:    rle_handler,\n80:    gdcm_handler,\n81:    pillow_handler,\n82:    jpegls_handler,\n83:]\n84:\"\"\"Handlers for converting (7fe0,0010) Pixel Data.\n85:This is an ordered list that the dataset.convert_pixel_data()\n86:method will try to extract a correctly sized numpy array from the\n87:PixelData element.\n88:\n89:Handers shall have two methods:\n90:\n91:def supports_transfer_syntax(ds)\n92:  This returns True if the handler might support the transfer syntax\n93:  indicated in the dicom_dataset\n94:\n95:def get_pixeldata(ds):\n96:  This shall either throw an exception or return a correctly sized numpy\n97:  array derived from the PixelData.  Reshaping the array to the correct\n98:  dimensions is handled outside the image handler\n99:\n100:The first handler that both announces that it supports the transfer syntax\n101:and does not throw an exception, either in getting the data or when the data\n102:is reshaped to the correct dimensions, is the handler that will provide the\n103:data.\n104:\n105:If they all fail, the last one to throw an exception gets to see its\n106:exception thrown up.\n107:\n108:If no one throws an exception, but they all refuse to support the transfer\n109:syntax, then this fact is announced in a NotImplementedError exception.\n110:\"\"\"\n111:\n112:\n113:def debug(debug_on=True):\n114:    \"\"\"Turn debugging of DICOM file reading and writing on or off.\n115:    When debugging is on, file location and details about the\n116:    elements read at that location are logged to the 'pydicom'\n117:    logger using python's logging module.\n118:\n119:    :param debug_on: True (default) to turn on debugging,\n120:    False to turn off.\n121:    \"\"\"\n122:    global logger, debugging\n123:    if debug_on:\n124:        logger.setLevel(logging.DEBUG)\n125:        debugging = True\n126:    else:\n127:        logger.setLevel(logging.WARNING)\n128:        debugging = False\n129:\n130:\n131:# force level=WARNING, in case logging default is set differently (issue 103)\n132:debug(False)\n\ndicom.py\n1:msg = \"\"\"\n2:Pydicom via 'import dicom' has been removed in pydicom version 1.0.\n3:Please install the `dicom` package to restore function of code relying\n4:on pydicom 0.9.9 or earlier. E.g. `pip install dicom`.\n5:Alternatively, most code can easily be converted to pydicom > 1.0 by\n6:changing import lines from 'import dicom' to 'import pydicom'.\n7:See the Transition Guide at\n8:https://pydicom.github.io/pydicom/stable/transition_to_pydicom1.html.\n9:\"\"\"\n10:\n11:raise ImportError(msg)\n\npydicom/util/__init__.py\n\npydicom/pixel_data_handlers/pillow_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Use the pillow python package to decode pixel transfer syntaxes.\"\"\"\n3:\n4:import io\n5:import logging\n6:\n7:try:\n8:    import numpy\n9:    HAVE_NP = True\n10:except ImportError:\n11:    HAVE_NP = False\n12:\n13:try:\n14:    from PIL import Image\n15:    HAVE_PIL = True\n16:except ImportError:\n17:    HAVE_PIL = False\n18:\n19:try:\n20:    from PIL import _imaging\n21:    HAVE_JPEG = getattr(_imaging, \"jpeg_decoder\", False)\n22:    HAVE_JPEG2K = getattr(_imaging, \"jpeg2k_decoder\", False)\n23:except ImportError:\n24:    HAVE_JPEG = False\n25:    HAVE_JPEG2K = False\n26:\n27:import pydicom.encaps\n28:from pydicom.pixel_data_handlers.util import dtype_corrected_for_endianness\n29:import pydicom.uid\n30:\n31:\n32:logger = logging.getLogger('pydicom')\n33:\n34:PillowSupportedTransferSyntaxes = [\n35:    pydicom.uid.JPEGBaseline,\n36:    pydicom.uid.JPEGLossless,\n37:    pydicom.uid.JPEGExtended,\n38:    pydicom.uid.JPEG2000Lossless,\n39:]\n40:PillowJPEG2000TransferSyntaxes = [\n41:    pydicom.uid.JPEG2000Lossless,\n42:]\n43:PillowJPEGTransferSyntaxes = [\n44:    pydicom.uid.JPEGBaseline,\n45:    pydicom.uid.JPEGExtended,\n46:]\n47:\n48:HANDLER_NAME = 'Pillow'\n49:\n50:DEPENDENCIES = {\n51:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n52:    'PIL': ('https://python-pillow.org/', 'Pillow'),\n53:}\n54:\n55:\n56:def is_available():\n57:    \"\"\"Return True if the handler has its dependencies met.\"\"\"\n58:    return HAVE_NP and HAVE_PIL\n59:\n...\n150:    numpy_format = dtype_corrected_for_endianness(\n151:        dicom_dataset.is_little_endian, numpy_format)\n152:\n153:    # decompress here\n154:    if transfer_syntax in PillowJPEGTransferSyntaxes:\n155:        logger.debug(\"This is a JPEG lossy format\")\n156:        if dicom_dataset.BitsAllocated > 8:\n157:            raise NotImplementedError(\"JPEG Lossy only supported if \"\n158:                                      \"Bits Allocated = 8\")\n159:        generic_jpeg_file_header = b''\n160:        frame_start_from = 0\n161:    elif transfer_syntax in PillowJPEG2000TransferSyntaxes:\n162:        logger.debug(\"This is a JPEG 2000 format\")\n163:        generic_jpeg_file_header = b''\n164:        # generic_jpeg_file_header = b'\\x00\\x00\\x00\\x0C\\x6A'\n165:        #     b'\\x50\\x20\\x20\\x0D\\x0A\\x87\\x0A'\n166:        frame_start_from = 0\n167:    else:\n168:        logger.debug(\"This is a another pillow supported format\")\n169:        generic_jpeg_file_header = b''\n170:        frame_start_from = 0\n171:\n172:    try:\n173:        UncompressedPixelData = bytearray()\n174:        if ('NumberOfFrames' in dicom_dataset and\n175:                dicom_dataset.NumberOfFrames > 1):\n176:            # multiple compressed frames\n177:            CompressedPixelDataSeq = \\\n178:                pydicom.encaps.decode_data_sequence(\n179:                    dicom_dataset.PixelData)\n...\n\npydicom/__init__.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"pydicom package -- easily handle DICOM files.\n3:   See Quick Start below.\n4:\n5:-----------\n6:Quick Start\n7:-----------\n8:\n9:1. A simple program to read a dicom file, modify a value, and write to a new\n10:   file::\n11:\n12:    from pydicom.filereader import dcmread\n13:    dataset = dcmread(\"file1.dcm\")\n14:    dataset.PatientName = 'anonymous'\n15:    dataset.save_as(\"file2.dcm\")\n16:\n17:2. See the files in the examples directory that came with this package for more\n18:   examples, including some interactive sessions.\n19:\n20:3. Learn the methods of the Dataset class; that is the one you will work with\n21:   most directly.\n22:\n23:4. Questions and comments can be directed to the pydicom google group:\n24:   http://groups.google.com/group/pydicom\n25:\n26:5. Bugs and other issues can be reported in the issue tracker:\n27:   https://www.github.com/pydicom/pydicom\n28:\n29:\"\"\"\n30:\n31:\n32:from pydicom.dataelem import DataElement\n33:from pydicom.dataset import Dataset, FileDataset\n34:from pydicom.filereader import dcmread, read_file\n35:from pydicom.filewriter import dcmwrite, write_file\n36:from pydicom.sequence import Sequence\n37:\n38:from ._version import __version__, __version_info__\n39:\n40:__all__ = ['DataElement',\n41:           'Dataset',\n42:           'FileDataset',\n43:           'Sequence',\n44:           'dcmread',\n45:           'dcmwrite',\n46:           'read_file',\n47:           'write_file',\n48:           '__version__',\n49:           '__version_info__']\n50:\n51:from pydicom.compat import in_py2\n52:if in_py2:\n53:    import warnings\n54:    msg = 'Python 2 will no longer be supported after the pydicom v1.4 release'\n55:    warnings.warn(msg, DeprecationWarning)\n\npydicom/pixel_data_handlers/__init__.py\n\npydicom/pixel_data_handlers/jpeg_ls_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"\n3:Use the jpeg_ls (CharPyLS) python package to decode pixel transfer syntaxes.\n4:\"\"\"\n5:\n6:try:\n7:    import numpy\n8:    HAVE_NP = True\n9:except ImportError:\n10:    HAVE_NP = False\n11:\n12:try:\n13:    import jpeg_ls\n14:    HAVE_JPEGLS = True\n15:except ImportError:\n16:    HAVE_JPEGLS = False\n17:\n18:import pydicom.encaps\n19:from pydicom.pixel_data_handlers.util import dtype_corrected_for_endianness\n20:import pydicom.uid\n21:\n22:\n23:HANDLER_NAME = 'JPEG-LS'\n24:\n25:DEPENDENCIES = {\n26:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n27:    'jpeg_ls': ('https://github.com/Who8MyLunch/CharPyLS', 'CharPyLS'),\n28:}\n29:\n...\n\npydicom/tests/__init__.py\n\ndoc/getting_started.rst\n1:.. _getting_started:\n2:\n3:============================\n4:Getting Started with pydicom\n5:============================\n6:\n7:.. rubric:: Brief overview of pydicom and how to install.\n8:\n9:\n10:Introduction\n11:============\n12:\n13:Pydicom is a pure Python package for working with `DICOM\n14:<http://en.wikipedia.org/wiki/DICOM>`_ files such as medical images, reports,\n15:and radiotherapy objects.\n16:\n17:Pydicom makes it easy to read these complex files into natural pythonic\n18:structures for easy manipulation. Modified datasets can be written again to\n19:DICOM format files.\n20:\n21:Here is a simple example of using pydicom in an interactive session, to read a\n22:radiotherapy plan file, change the patient setup from head-first-supine to\n23:head-first-prone, and save to a new file::\n24:\n25:  >>> import os\n26:  >>> import pydicom\n27:  >>> from pydicom.data import get_testdata_files\n28:  >>> filename = get_testdata_files(\"rtplan.dcm\")[0]\n29:  >>> ds = pydicom.dcmread(filename)  # plan dataset\n30:  >>> ds.PatientName\n31:  'Last^First^mid^pre'\n32:  >>> ds.dir(\"setup\")    # get a list of tags with \"setup\" somewhere in the name\n33:  ['PatientSetupSequence']\n34:  >>> ds.PatientSetupSequence[0]\n35:  (0018, 5100) Patient Position                    CS: 'HFS'\n36:  (300a, 0182) Patient Setup Number                IS: '1'\n37:  (300a, 01b2) Setup Technique Description         ST: ''\n38:  >>> ds.PatientSetupSequence[0].PatientPosition = \"HFP\"\n39:  >>> ds.save_as(\"rtplan2.dcm\")\n40:\n41:..\n42:  >>> os.remove(\"rtplan2.dcm\")\n43:\n44:Pydicom is not a DICOM server [#]_, and is not primarily about viewing\n45:images. It is designed to let you manipulate data elements in DICOM files with\n46:Python code.\n47:\n48:Pydicom is easy to install and use, and because it is a pure Python package, it\n49:should run wherever Python runs.\n50:\n51:One limitation of pydicom: compressed pixel data (e.g. JPEG) can only be\n52:altered in an intelligent way if :doc:`decompressing </image_data_handlers>`\n53:them first. Once decompressed, they can be altered and written back to a\n54:DICOM file the same way as initially uncompressed data.\n55:\n56:License\n57:=======\n58:\n59:Pydicom has an MIT-based `license\n60:<https://github.com/pydicom/pydicom/blob/master/LICENSE>`_.\n61:\n62:Installing\n63:==========\n64:\n65:As a pure Python package, pydicom is easy to install and has no requirements\n66:other than Python itself (the NumPy library is recommended, but is only\n67:required if manipulating pixel data).\n68:\n69:\n70:Prerequisites\n71:-------------\n72:\n73:* Python 2.7, 3.4 or later\n74:* Optional dependencies:\n75:   * numpy\n76:   * pillow\n77:   * gdcm\n78:   * jpeg_ls\n79:   * jpeg2000\n80:   * pytest (if running pydicom's test suite). pytest<5 if in Python 2.\n81:\n82:\n83:Installing pydicom\n84:------------------\n85:\n86:Pydicom is currently available on `PyPi <https://pypi.python.org/pypi/pydicom/>`_\n87:. The simplest way to install pydicom alone is using ``pip`` at a command line::\n88:\n89:  pip install -U pydicom\n90:\n91:which installs the latest release.  To install the latest code from the repository\n92:(usually stable, but may have undocumented changes or bugs)::\n93:\n94:  pip install -U git+https://github.com/pydicom/pydicom.git\n95:\n96:\n97:Pydicom is also available on conda-forge::\n98:\n99:  conda install pydicom --channel conda-forge\n100:\n101:To install pydicom along with image handlers for compressed pixel data, \n102:we encourage you to use `Miniconda <https://conda.io/miniconda.html>`_ or\n103:`Anaconda <https://docs.continuum.io/anaconda/>`_.  For example::\n104:\n105:  conda create --name pydicomenv python=3.6 pip numpy\n106:  conda install pydicom --channel conda-forge\n107:\n108:will install pip, pydicom, and numpy in an environment called pydicomenv.  \n109:To add gdcm after activating the environment::\n110:\n111:  conda install -c conda-forge gdcm\n112:\n113:The environment is optional; see the conda software for details of its setup \n114:and use of environments.\n115:\n116:For developers, you can clone the pydicom repository and run \n117:the ``setup.py`` file. Use the following commands to get a copy \n118:from GitHub and install all dependencies::\n119:\n120:  git clone https://github.com/pydicom/pydicom.git\n121:  cd pydicom\n122:  pip install .\n123:\n124:or, for the last line, instead use::\n125:\n126:  pip install -e .\n127:\n128:to install in 'develop' or 'editable' mode, where changes can be made to the\n129:local working code and Python will use the updated pydicom code.\n130:\n131:\n132:Test and coverage\n133:=================\n134:\n135:To test the installed code on any platform, change to the directory of \n136:pydicom's setup.py file and::\n137:\n138:  python setup.py test\n139:\n140:This will install `pytest <https://pytest.org>`_ if it is not \n141:already installed.\n142:\n143:In v1.3 run under Python 2, if pytest is not found, please `python2 -m pip install \"pytest<5\"`\n144:  \n145:Or, in linux you can also use::\n146:\n147:  make test-code\n148:\n149:To test the coverage of your versions in linux::\n150:\n151:  make test-coverage\n152:\n153:\n154:Using pydicom\n155:=============\n156:\n157:Once installed, the package can be imported at a Python command line or used\n158:in your own Python program with ``import pydicom``.\n159:See the `examples directory\n160:<https://github.com/pydicom/pydicom/tree/master/examples>`_\n161:for both kinds of uses. Also see the :doc:`User Guide </pydicom_user_guide>`\n162:for more details of how to use the package.\n163:\n164:Support\n165:=======\n166:\n167:Please join the `pydicom discussion group\n168:<http://groups.google.com/group/pydicom>`_ to ask questions or give feedback.\n169:Bugs can be submitted through the `issue tracker\n170:<https://github.com/pydicom/pydicom/issues>`_.  Besides the example directory,\n171:cookbook recipes are encouraged to be posted on the `wiki page\n172:<https://github.com/pydicom/pydicom/wiki>`_.\n173:\n174:New versions, major bug fixes, etc. will also be announced through the group.\n175:\n176:Next Steps\n177:==========\n178:\n179:To start learning how to use pydicom, see the :doc:`pydicom_user_guide`.\n180:\n181:.. rubric:: Footnotes::\n182:\n183:.. [#] For DICOM network capabilities, see the\n184:   `pynetdicom <https://github.com/patmun/pynetdicom>`_ and the newer\n185:   `pynetdicom3 <https://github.com/pydicom/pynetdicom3>`_ projects.\n186:.. [#] If using python(x,y), other packages you might be interested in include IPython\n187:   (an indispensable interactive shell with auto-completion, history etc),\n188:   NumPy (optionally used by pydicom for pixel data), and ITK/VTK or PIL\n189:   (image processing and visualization).\n\npydicom/pixel_data_handlers/gdcm_handler.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\"\"\"Use the gdcm python package to decode pixel transfer syntaxes.\"\"\"\n3:\n4:import sys\n5:\n6:try:\n7:    import numpy\n8:    HAVE_NP = True\n9:except ImportError:\n10:    HAVE_NP = False\n11:\n12:try:\n13:    import gdcm\n14:    HAVE_GDCM = True\n15:    HAVE_GDCM_IN_MEMORY_SUPPORT = hasattr(gdcm.DataElement,\n16:                                          'SetByteStringValue')\n17:except ImportError:\n18:    HAVE_GDCM = False\n19:    HAVE_GDCM_IN_MEMORY_SUPPORT = False\n20:\n21:import pydicom.uid\n22:from pydicom import compat\n23:from pydicom.pixel_data_handlers.util import get_expected_length, pixel_dtype\n24:\n25:\n26:HANDLER_NAME = 'GDCM'\n27:\n28:DEPENDENCIES = {\n29:    'numpy': ('http://www.numpy.org/', 'NumPy'),\n...\n\npydicom/tests/test_pillow_pixel_data.py\n1:# Copyright 2008-2018 pydicom authors. See LICENSE file for details.\n2:\n3:import os\n4:import sys\n5:\n6:import pytest\n7:\n8:import pydicom\n9:from pydicom.filereader import dcmread\n10:from pydicom.data import get_testdata_files\n11:from pydicom.tag import Tag\n12:\n13:# Python 3.4 pytest does not have pytest.param?\n14:have_pytest_param = hasattr(pytest, 'param')\n15:\n16:try:\n17:    from pydicom.pixel_data_handlers import numpy_handler\n18:    HAVE_NP = numpy_handler.HAVE_NP\n19:except ImportError:\n20:    HAVE_NP = False\n21:    numpy_handler = None\n22:\n23:try:\n24:    from pydicom.pixel_data_handlers import pillow_handler\n25:    HAVE_PIL = pillow_handler.HAVE_PIL\n26:    HAVE_JPEG = pillow_handler.HAVE_JPEG\n27:    HAVE_JPEG2K = pillow_handler.HAVE_JPEG2K\n28:    import numpy as np\n29:except ImportError:\n30:    pillow_handler = None\n31:    HAVE_PIL = False\n32:    HAVE_JPEG = False\n33:    HAVE_JPEG2K = False\n34:\n35:\n36:pillow_missing_message = (\"pillow is not available \"\n37:                          \"in this test environment\")\n38:\n39:TEST_PIL = HAVE_NP and HAVE_PIL\n40:TEST_JPEG = TEST_PIL and HAVE_JPEG\n41:TEST_JPEG2K = TEST_PIL and HAVE_JPEG2K\n42:\n43:empty_number_tags_name = get_testdata_files(\n44:    \"reportsi_with_empty_number_tags.dcm\")[0]\n45:rtplan_name = get_testdata_files(\"rtplan.dcm\")[0]\n46:rtdose_name = get_testdata_files(\"rtdose.dcm\")[0]\n47:ct_name = get_testdata_files(\"CT_small.dcm\")[0]\n48:mr_name = get_testdata_files(\"MR_small.dcm\")[0]\n49:truncated_mr_name = get_testdata_files(\"MR_truncated.dcm\")[0]\n50:jpeg2000_name = get_testdata_files(\"JPEG2000.dcm\")[0]\n51:jpeg2000_lossless_name = get_testdata_files(\n52:    \"MR_small_jp2klossless.dcm\")[0]\n53:jpeg_ls_lossless_name = get_testdata_files(\n54:    \"MR_small_jpeg_ls_lossless.dcm\")[0]\n55:jpeg_lossy_name = get_testdata_files(\"JPEG-lossy.dcm\")[0]\n56:jpeg_lossless_name = get_testdata_files(\"JPEG-LL.dcm\")[0]\n57:deflate_name = get_testdata_files(\"image_dfl.dcm\")[0]\n58:rtstruct_name = get_testdata_files(\"rtstruct.dcm\")[0]\n59:priv_SQ_name = get_testdata_files(\"priv_SQ.dcm\")[0]\n...\n\ndoc/transition_to_pydicom1.rst\n1:.. _transition_to_pydicom1:\n2:\n3:Transition to pydicom 1.x\n4:=========================\n5:\n6:.. rubric:: Important information on differences in pydicom post 1.0 vs pre-1.0\n7:\n8:Introduction\n9:------------\n10:\n11:As is often the case for major software version number changes, pydicom 1.0\n12:breaks with the previous release of pydicom (0.9.9) in several ways.  These\n13:require changes to user code to target the pydicom >= 1.0 package, or to check\n14:and deal with the differences between the versions.\n15:\n16:Backwards-incompatible changes post 1.0\n17:\n18:  * the library is no longer ``dicom`` but is ``pydicom``, to match the package\n19:    name\n20:  * short-form names such as ``Beams`` are no longer allowed; use the full\n21:    keyword e.g. ``BeamSequence``\n22:  * some less-used modules within pydicom have been renamed, e.g. ``dicom.UID``\n23:    is now ``pydicom.uid``\n24:\n25:Why was the package name changed?  There are several reasons for this change:\n26:\n27:  * it is standard Python practice for the package and the installed library to\n28:    have the same name\n29:  * first-time users expect to be able to type ``import pydicom`` rather than\n30:    ``import dicom``, which has caused confusion\n31:  * it makes sense for search engines - with the correct name it is much easier\n32:    to find relevant questions and example code online\n33:\n34:The decision wasn't taken lightly, but with a great deal of discussion on the\n35:GitHub issues list.  Having made the leap, the rest of this guide should help\n36:smooth the way...\n37:\n38:For authors of packages requiring pydicom < 1.0\n39:-----------------------------------------------\n40:\n41:The old pydicom releases have been split off into their own package, called\n42:``dicom``, which is now hosted on PyPI. This allows the old library ``dicom``\n43:to co-exist alongside the new library ``pydicom``.\n44:\n45:The main things to do, to ensure your old pydicom code will remain functional,\n46:are:\n47:\n48:   (a) you should ``pip uninstall pydicom`` and ``pip install dicom`` in your\n49:       existing pydicom installs\n50:   (b) If you have ``requirements.txt`` files, change the pydicom line from\n51:       \"pydicom\" to \"dicom\" e.g.  ``pydicom==0.9.9`` becomes ``dicom==0.9.9``\n52:   (c) Change your instructions to users to ``pip install dicom`` rather than\n53:       ``pip install pydicom``\n54:\n55:\n56:Error messages relating to the pydicom transition\n57:-------------------------------------------------\n58:\n59:This section is here in the hopes of people getting directed to this page on\n60:searches. If that's you, then welcome! Hopefully the information here can get\n61:things going quickly for you.\n62:\n63:For those with pydicom < 1.0 installed, on trying to import pydicom, they will\n64:get an ImportError message::\n65:\n66:  >>> import pydicom # doctest: +SKIP\n67:  Traceback (most recent call last):\n68:    File \"<stdin>\", line 1, in <module>\n69:  ImportError: No module named pydicom\n70:\n71:Your choice then is to update to pydicom >=1.0 (see Installing pydicom\n72:section), or to instead use ``import dicom`` and follow the old-style pydicom\n73:syntax.\n74:\n75:Conversely, if pydicom >= 1.0 is installed, the error message for ``import\n76:dicom`` will look like::\n77:\n78:  >>> import dicom # doctest: +SKIP\n79:  Traceback (most recent call last):\n80:    File \"<stdin>\", line 1, in <module>\n81:  ImportError: No module named dicom\n82:\n83:In this case you likely have installed pydicom >= 1.0, and so the ``dicom`` library\n84:does not exist.  You can simply ``import pydicom`` instead, and continue with\n85:the new pydicom, or, if you really need the old pydicom, then you should::\n86:\n87:  pip install dicom\n88:\n89:and you should be good to go.\n90:\n91:\n92:API Changes in version 1.0\n93:==========================\n94:\n95:Apart from the change of the package name, there are some changes in\n96:module names, class names, and behavior that may require some code changes.\n97:\n98:Changed module names\n99:--------------------\n100:\n101:  * module ``UID`` is now ``uid``\n102:\n103:Changed function and variable names\n104:-----------------------------------\n105:\n106:  * in module ``datadict``:\n107:\n108:    * ``dictionaryVM()`` -> ``dictionary_VM``\n109:    * ``dictionaryVR()`` -> ``dictionary_VR``\n110:    * ``private_dictionaryVM()`` -> ``private_dictionary_VM``\n111:    * ``private_dictionaryVR()`` -> ``private_dictionary_VR``\n112:  * in module ``filereader``:\n113:\n114:    * ``read_file()`` -> ``dcmread()`` (but old name remains for compatibility)\n115:  * in module ``filewriter``:\n116:\n117:    * ``write_file()`` -> ``dcmwrite()`` (but old name remains for compatibility)\n118:  * module ``tagtools``:\n119:\n120:    * ``tag_in_exception()`` has been moved to ``tag`` module\n121:  * module ``uid``:\n122:\n123:    * ``UID.is_valid()`` is now a property\n124:    * ``NotCompressedPixelTransferSyntaxes`` ->  ``UncompressedPixelTransferSyntaxes``\n125:    * ``pydicom_root_UID`` -> ``PYDICOM_ROOT_UID``\n126:\n127:Removed functions and names\n128:---------------------------\n129:\n130:  * support for old names (before DICOM keywords) in module ``datadict`` is\n131:    gone (``CleanName()``, ``short_name()``, ``long_name()``,\n132:    ``all_names_for_tag()``\n133:  * ``filereader.not_group2()`` is no longer available\n134:  * ``uid.pydicom_UIDs`` has been removed\n135:\n136:Changed behavior\n137:----------------\n138:\n139:  * ``dataset.save_as()``:  ``TransferSyntaxUID`` not added automatically to ``dataset.file_meta`` if\n140:    missing\n\npydicom/dataset.py\n...\n1260:                missing = [dd for dd in hh_deps if have_package(dd) is None]\n1261:                # Package names\n1262:                names = [hh_deps[name][1] for name in missing]\n1263:                pkg_msg.append(\n1264:                    \"{} (req. {})\"\n1265:                    .format(hh.HANDLER_NAME, ', '.join(names))\n1266:                )\n1267:\n1268:            raise RuntimeError(msg + ', '.join(pkg_msg))\n1269:\n1270:        last_exception = None\n1271:        for handler in available_handlers:\n1272:            try:\n1273:                # Use the handler to get a 1D numpy array of the pixel data\n1274:                arr = handler.get_pixeldata(self)\n1275:                self._pixel_array = reshape_pixel_array(self, arr)\n1276:\n1277:                # Some handler/transfer syntax combinations may need to\n1278:                #   convert the color space from YCbCr to RGB\n1279:                if handler.needs_to_convert_to_RGB(self):\n1280:                    self._pixel_array = convert_color_space(self._pixel_array,\n1281:                                                            'YBR_FULL',\n1282:                                                            'RGB')\n1283:\n1284:                self._pixel_id = id(self.PixelData)\n1285:\n1286:                return\n1287:            except Exception as exc:\n1288:                logger.debug(\n1289:                    \"Exception raised by pixel data handler\", exc_info=exc\n...\n"
                    }
                }
            }
        ],
        "stream": false,
        "temperature": null,
        "max_tokens": null,
        "response_format": null
    },
    "text": "Here is a plan to address the issue of pydicom defining the logging handler, formatter and level:\n\n1. Remove the following lines from pydicom/config.py that define the logger, handler, formatter and log level:\n```\nlogger = logging.getLogger('pydicom')  \nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\"%(message)s\")\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\n```\n\n2. Also remove the `debug()` function from pydicom/config.py that sets the log level. \n\n3. Remove the call to `debug(False)` near the end of pydicom/config.py that forces the log level to WARNING.\n\n4. Update any code in the pydicom modules that uses the `logger` from pydicom.config to get the logger directly, e.g.:\n```\nlogger = logging.getLogger('pydicom')\n```\n\n5. Document in the release notes, migration guide, and logging documentation that client code is now responsible for configuring the pydicom logger if desired, rather than pydicom doing it automatically.\n\n6. Add an example in the documentation of how to configure basic logging for pydicom, e.g.:\n```\nimport logging\nlogger = logging.getLogger('pydicom')\nlogger.setLevel(logging.DEBUG)\nhandler = logging.StreamHandler()\nformatter = logging.Formatter(\"%(levelname)s %(message)s\")\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\n```\n\n7. Update any pydicom example code that relies on the automatic logging configuration to configure it explicitly.\n\n8. Add tests to check that no logging output occurs by default when importing pydicom or using its modules.\n\nThis will remove the automatic logging configuration by pydicom itself, while still allowing the 'pydicom' logger to be used by the library code. Clients can then have full control over configuring the logger as needed for their use case.",
    "total_time": 34.036009415998706,
    "input_tokens": 9518,
    "output_tokens": 447,
    "completed": true,
    "cost": 17.6295
}
