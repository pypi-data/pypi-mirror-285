# mypy: disable-error-code="var-annotated"
from __future__ import annotations

import pathlib
import re
import sys
import textwrap

from collections import ChainMap, deque, namedtuple
from functools import cached_property, partial, partialmethod
from itertools import chain
from shutil import get_terminal_size
from typing import Any, Callable, Optional, Sequence

from clipp.utils import (
    index_view,
    is_homogeneous,
    is_number,
    MappingView,
    Polymap,
    ReadOnlyAttribute,
    SetFamily,
    unique_sort,
)
# todo: raise a warning to users regarding flags which are also valid integers.
# todo: add support for unix pipes and a standard mode for single-dash.
# todo: add support for shell completion.
# todo: add a fast parsing option which avoids pre-processing for cases in
#  which users do not add sub-commands.

# For type hints. Use `cached_property` if the attribute is not callable.
cached_callable: Callable = cached_property

__all__ = ["Command", "OptionGroup"]

Member = namedtuple("Member", "name value")
Namespace = namedtuple("Namespace", "globals locals extra")
ParsedArguments = namedtuple("ParsedArguments", "globals locals")

ESC = "--"
INF = float("inf")
EAGER_OPS = "*+"
ZERO_OR_ONE = "?"
LPAD = 22
RJUST = " " * LPAD

fill_text = partial(
    textwrap.fill,
    break_on_hyphens=False,
    replace_whitespace=False,
)


def truncate(array: str, by: int) -> str:
    """
    Truncate the string `by` the specificed number of characters. If the size
    of the string is already less than or equal to the number of
    characters to be trimmed, return the original string.
    """
    i = len(array) - by
    if i <= 0:
        return array
    return array[:i]


def get_indent(text: str) -> str:
    """Get the indentation (if any) of the supplied string. """
    indent = ""
    for char in text:
        if char in "\t ":
            indent += char
        else:
            return indent
    return indent


def fill_paragraph(
        text: str,
        width: int = 70,
        initial_indent: str = "",
        subsequent_indent: str = "",
        ):
    """
    Multi-line text fill which retains leading indentation for each line.

    Parameters
    ----------
    text : `str`
        The text to be filled (wrapped).
    width : `int`
        The maximum width for each line. If the width is longer than the
        terminal width, the terminal width will be used instead.
    initial_indent : `str`
        The indent for the first line of the string.
    subsequent_indent : `str`
        The indent for all lines following the first. This includes new lines
        generated by wrapping the text.

    Returns
    -------
    The filled/wrapped text.
    """
    # I do not claim to understand why `textwrap` works the way it does,
    # nor am I certain that its functionality aligns with its own spec. I don't
    # care. This function works. Do not touch it!
    if width > (cols := get_terminal_size().columns):
        width = cols

    chunks = text.split("\n")
    # When filling the first line, the specified initial and subsequent
    # indents need to be honored.
    para = fill_text(
        chunks[0],
        width=width,
        initial_indent=initial_indent,
        subsequent_indent=subsequent_indent,
        drop_whitespace=True,
    )
    lines = para.split("\n")
    # If the first line contains only whitespace, remove it.
    i = 1 if lines[0].lstrip() == "" else 0
    chunks[0] = "\n".join(lines[i:])
    # Dropping whitespace here would remove indentation we wish to retain.
    paragraphs = (
        fill_text(ln, width=width, drop_whitespace=False)
        for ln in chunks[1:] # We've already formatted the first chunk.
    )
    for i, para in enumerate(paragraphs, start=1):
        # The initial indent and subsequent indent must match the leading
        # indent of the paragraph but also honor the subseqeunt indent which
        # was supplied as an argument.
        indent = get_indent(para) + subsequent_indent
        # We can now allow leading and trailing whitespace to be dropped.
        chunks[i] = fill_text(
            para.lstrip(),
            width=width,
            initial_indent=indent,
            subsequent_indent=indent,
            drop_whitespace=True,
        )

    return "\n".join(chunks)


def is_property(value: Any) -> bool:
    """Indicates whether the attribute is a property."""
    return isinstance(value, (property, cached_property))


def get_properties(obj: Any) -> list[Member]:
    """
    Wrapper for `inspect.getmembers` which returns a dictionary containing the
    names and values for each of the properties of the instance supplied.
    """
    from inspect import getmembers
    return [Member(*t) for t in getmembers(obj, is_property)]


class RelationalIntegrityError(Exception):
    """
    Raised whenever operations on an option group would cause the group or
    any of its elements to lose relational integrity.
    """


class AmbiguityError(Exception):
    """Raised whenever an operation would lead to an ambiguous state."""


def is_valid_alias(
        value: str,
        short_pattern: re.Pattern,
        long_pattern=re.compile(r"^--[a-zA-Z0-9]+(-[a-zA-Z0-9]+)*$"),
        ) -> bool:
    """
    Confirm whether the string represents a valid short or long option alias.
    """
    if value.startswith("--"):
        # Long aliases must be at least four characters in length, including
        # dashes. Rather than further complicate the regex, it is much
        # simpler to check the length first.
        if len(value) < 4:
            return False
        return bool(long_pattern.match(value))
    else:
        return bool(short_pattern.match(value))


class Aliases(ReadOnlyAttribute):
    """
    Descriptor which ensures that each value is a valid long or short alias
    string.
    """
    _is_valid_alias = partial(
        is_valid_alias, short_pattern=re.compile(r"^-[a-zA-Z]?$"))
    _is_valid_flag_alias = partial(
        is_valid_alias, short_pattern=re.compile(r"^-[a-zA-Z0-9]?$"))

    def __init__(self, is_flag: bool = False):
        self.is_flag = is_flag

    def __set__(self, instance, iterable: Sequence[str]):
        if self.is_flag:
            is_valid = self._is_valid_flag_alias
        else:
            is_valid = self._is_valid_alias

        for v in iterable:
            if not is_valid(v):
                raise ValueError(f"invalid alias: '{v}'")

        super().__set__(instance, iterable)


class PositionalName(ReadOnlyAttribute):
    """
    Descriptor which ensures that the value is a string which contains only
    letters, numbers, and non-leading/non-trailing dashes.
    """
    positional_name = re.compile(r"^[a-zA-Z0-9]+(-[a-zA-Z0-9]+?)*$")

    def __set__(self, instance, value):
        if not self.positional_name.match(value):
            raise ValueError(f"invalid positional name: '{value}'")

        super().__set__(instance, value)


class Quota(ReadOnlyAttribute):
    """
    Descriptor which ensures that the value of the quota is not less than
    `minsize`.
    """

    def __init__(self, minsize: int):
        self.minsize = minsize

    def __set__(self, instance, value):
        if value < self.minsize:
            raise ValueError(
                f"expected a value greater than {self.minsize - 1};"
                f" got '{value}'"
            )

        super().__set__(instance, value)


class Choice(ReadOnlyAttribute):
    """Descriptor which ensures that all values are valid choice strings."""

    def __set__(self, instance, iterable: Sequence[str]):
        for value in iterable:
            # Allowing leading or trailing spaces would really upset the
            # end-user.
            if value[0] == " " or value[-1] == " ":
                raise ValueError(f"choices cannot have leading/trailing spaces")

            # If the value starts with a dash then it needs to be a number. The
            # parser treats space-delimited strings as single tokens and will
            # attempt to decompose a token if it does not represent a valid
            # number. If the token represents a choice, then this is not
            # desired.
            if value[0] == "-" and not is_number(value):
                raise ValueError(f"'{value}' is not a valid choice")

        super().__set__(instance, iterable)


class Reference(ReadOnlyAttribute):
    """
    Descriptor which hijacks attribute access and returns the specified
    attribute of some other attribute (`attr_name`) in the instance dictionary.
    """

    def __init__(self, attr_name: str):
        self.attr_name = attr_name

    def __get__(self, instance, owner):
        if instance is None:
            return self
        return instance.__dict__[self.attr_name].__dict__[self.name]


def identity(value: Any) -> Any:
    return value


class Option:
    """Data container representing a user-defined option."""
    # Descriptors are used to validate arguments as well as restrict
    # assignment to sensitive attributes. Users are not expected to
    # instantiate this class or any of its sub-classes directly.
    aliases = Aliases(is_flag=False)
    name = ReadOnlyAttribute()
    quota = Quota(minsize=1)
    choices = Choice()
    required = ReadOnlyAttribute()
    is_global = ReadOnlyAttribute()
    _dtype = ReadOnlyAttribute()
    _profile = ReadOnlyAttribute()
    _action = ReadOnlyAttribute()
    _is_fast = False

    def __init__(
            self,
            *aliases: str,
            dest: str = "",
            quota: int | str = 1,
            choices: Sequence[str] = tuple(),
            default: Any = None,
            const: Any = None,
            dtype: Optional[Callable] = None,
            action: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            required: bool = False,
            is_global: bool = False,
            ):
        err_msg = "%s not supported for quota '%s'"
        if choices and quota != 1:
            raise ValueError(err_msg % ("choices", quota))

        if not self._supports_defaults(quota):
            if const is not None:
                raise ValueError(err_msg % ("const", quota))

            if default is not None:
                raise ValueError(err_msg % ("default", quota))

        self.aliases = unique_sort(aliases)
        self.name = self.aliases[0]
        self.quota = self._coerce_quota(quota)
        self.choices = sorted(set(choices))
        self.required = required
        self.is_global = is_global
        self.help = help
        self._usage = usage
        self._profile = quota
        self._dest = dest
        self._default = default
        self._const = const
        self._dtype = dtype
        self._action = action
        self._is_dependent = False
        self._is_mutex = False

    @staticmethod
    def _coerce_quota(value: int | str) -> int | float:
        if not isinstance(value, (int, str)):
            raise TypeError(f"expected 'int' or 'str'; got {type(value)}")
        elif isinstance(value, str):
            if value not in EAGER_OPS:
                expected = ", ".join(EAGER_OPS)
                raise ValueError(
                    f"expected an integer greater than zero or one of "
                    f"{expected}; got '{value}'"
                )

            value = float("inf")

        return value

    @staticmethod
    def _supports_defaults(quota: int | str) -> bool:
        return quota == "*" or isinstance(quota, int) and quota <= 1

    def _get_effective_value(self, value: Any) -> None:
        if value is None:
            # A zero-or-more profile assumes that any number of values is
            # acceptable. In this case, it is not considered an error if the
            # parser does not consume any values, but the only logical
            # value to return (if one is not explicitly provided) is an empty
            # list.
            if self._profile == "*":
                return []
        return value

    @property
    def altname(self) -> str:
        """
        The alternative name for the option, used as the key in the namespace
        produced by parsing command-line arguments.
        """
        if self._dest:
            return self._dest
        return self.name.lstrip("--").replace("-", "_")

    @property
    def is_dependent(self) -> bool:
        """Indicates whether the option is part of a dependent group."""
        return self._is_dependent

    @property
    def is_mutex(self) -> bool:
        """
        Indicates whether the option is part of a mutually exclusive group.
        """
        return self._is_mutex

    @property
    def default(self) -> Any:
        """Get or set the option's default value."""
        return self._get_effective_value(self._default)

    @default.setter
    def default(self, value: Any) -> None:
        self._default = value

    @property
    def const(self) -> Any:
        """Get or set the option's constant value."""
        return self._get_effective_value(self._const)

    @const.setter
    def const(self, value: Any) -> None:
        self._const = value

    @property
    def has_default(self) -> bool:
        """Whether the option has a default value which is not `None`."""
        return self.default is not None

    @property
    def has_const(self) -> bool:
        """Whether the option has a constant value which is not `None`."""
        return self.const is not None

    @cached_callable
    def dtype(self) -> Callable:
        """
        Returns the callback function for converting tokens. If `dtype` is
        not explicitly supplied to the constructor, the callback will be an
        identity function.
        """
        if self._dtype:
            return self._dtype

        return identity

    def convert(self, value: Any) -> Any:
        try:
            return self.dtype(value)
        except Exception as err:
            help_prefix = "Help: "
            _help = fill_paragraph(
                self.help,
                subsequent_indent=" " * len(help_prefix),
            )
            msg = (
                f"ERROR: invalid value '{value}' supplied to {self.name}\n"
                f"{help_prefix}{fill_paragraph(_help)}"
            )
            sys.exit(msg)

    def action(self, value: Any) -> Any:
        """
        Optional callable for post-processing tokens collected by the parser.

        Parameters
        ----------
        value : `Any`, optional
            The value or list of values to be converted. If no callback
            function is supplied to the constructor, this method acts as an
            identity function and returns the original value.

        Returns
        -------
        The return value of the callback or the original value supplied.
        """
        if self._action:
            return self._action(value)
        return value

    def _meets_quota(self, values: list[Any]) -> int:
        if self._profile == "+":
            return len(values) >= 1
        elif self._profile != "*":
            return len(values) == self.quota
        # By definition, options with zero-or-more quota profiles always meet
        # their quotas.
        return True

    def _validate(self, values: list[Any]) -> None:
        # Termination is not dictated solely by whether or not the option has
        # met its quota. In some cases, we allow for the constant value to be
        # used when the quota is not met.
        if not self._meets_quota(values):
            if self._profile == "+":
                sys.exit(f"ERROR: {self.name} expects one or more arguments")
            elif isinstance(self.quota, int) and self.quota > 1:
                sys.exit(f"ERROR: {self.name} expects {self.quota} arguments")
            elif self.quota == 1 and not self.has_const:
                sys.exit(f"ERROR: {self.name} expects an argument")

        if self.choices and values:
            choice = values[0]
            if choice not in self.choices:
                sys.exit(
                    f"ERROR: invalid argument '{choice}' supplied to "
                    f"option '{self.name}'"
                )

    def format_help(self) -> str:
        """Format and return the option's help string."""
        prefix = ", ".join(self.aliases)
        too_long = len(prefix) > LPAD - 4
        if too_long:
            prefix += "\n"
            text = prefix + fill_paragraph(
                self.help,
                initial_indent=RJUST,
                subsequent_indent=RJUST,
            )
        else:
            prefix += truncate(RJUST, by=len(prefix))
            text = fill_paragraph(prefix + self.help, subsequent_indent=RJUST)

        return text

    @property
    def usage(self) -> str:
        """
        Get or set the option's usage string. If no usage string is set,
        the getter will attempt to infer the usage syntax.
        """
        if self._usage:
            return self._usage

        if self.quota > 0:
            if self.choices:
                suffix = "<" + "|".join(self.choices) + ">"
            else:
                suffix = "<arg>"

            if self.name.startswith("--"):
                text = f"{self.name}={suffix}"
            else:
                text = f"{self.name} {suffix}"
        else:
            text = self.name

        if not self.required:
            text = f"[{text}]"

        if self.quota > 1:
            return text + "..."
        return text

    @usage.setter
    def usage(self, value: str) -> str:
        self._usage = value

    def __repr__(self):
        exclude = ("help", "usage")
        public_props = dict(
            (m.name, getattr(self, m.name))
            for m in get_properties(self.__class__)
            if m.name[0] != "_"
        )
        attrs = {k: v for k, v in self.__dict__.items() if k[0] != "_"}
        attrs.update(public_props)
        for key in exclude:
            if key in attrs:
                del attrs[key]

        formatted = str(attrs).replace("{", "(").replace("}", ")")
        return f"{self.__class__.__name__}{formatted}"

    def __eq__(self, other):
        if not isinstance(other, Option):
            return NotImplemented

        return self.name == other.name

    def __hash__(self):
        return self.name.__hash__()


class Parameter(Option):
    """Data container representing a user-defined positional option."""
    name = ReadOnlyAttribute()
    # Do not validate aliases for parameters.
    aliases = ReadOnlyAttribute()

    def __init__(
            self,
            name: str,
            dest: str = "",
            quota: int | str = 1,
            choices: Sequence[str] = tuple(),
            default: Any = None,
            dtype: Optional[Callable] = None,
            action: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            ):
        required = False if quota == "*" or quota == "?" else True
        if quota == "?" and default is None:
            raise ValueError(
                "optional parameters which accept either zero or one argument "
                "(quota='?') must be supplied a default value"
            )

        super().__init__(
            name,
            dest=dest,
            quota=quota,
            choices=choices,
            default=default,
            dtype=dtype,
            action=action,
            help=help,
            usage=usage,
        )

    @staticmethod
    def _coerce_quota(value: int | str) -> int | float:
        if not isinstance(value, (int, str)):
            raise TypeError(f"expected 'int' or 'str'; got {type(value)}")
        elif isinstance(value, str):
            if value not in EAGER_OPS and value != ZERO_OR_ONE:
                print(value)
                expected = ", ".join(EAGER_OPS + ZERO_OR_ONE)
                raise ValueError(
                    f"expected an integer greater than zero or one of "
                    f"{expected}; got '{value}'"
                )

            if value == ZERO_OR_ONE:
                value = 1
            else:
                value = float("inf")

        return value

    @staticmethod
    def _supports_defaults(quota: int | str) -> bool:
        return quota == "*" or quota == "?"

    def _meets_quota(self, values: list[Any]) -> int:
        if self._profile == "+":
            return len(values) >= 1
        elif self._profile == "?":
            return len(values) == 1
        elif self._profile != "*":
            return len(values) == self.quota
        # By definition, options with zero-or-more or zero-or-one quota
        # profiles always meet their quotas.
        return True

    def _validate(self, values: list[Any]) -> None:
        # Termination is not dictated solely by whether or not the option has
        # met its quota. In some cases, we allow for the constant value to be
        # used when the quota is not met.
        if not self._meets_quota(values):
            if self._profile == "+":
                sys.exit(f"ERROR: {self.name} expects one or more arguments")
            elif isinstance(self.quota, int) and self.quota > 1:
                sys.exit(f"ERROR: {self.name} expects {self.quota} arguments")
            elif self.quota == 1 and not self.has_default:
                sys.exit(f"ERROR: {self.name} expects an argument")

        if self.choices and values:
            choice = values[0]
            if choice not in self.choices:
                sys.exit(
                    f"ERROR: invalid argument '{choice}' supplied to "
                    f"option '{self.name}'"
                )

    @property
    def usage(self) -> str:
        """
        Get or set the parameter's usage string. If no usage string is set,
        the getter will attempt to infer the usage syntax.
        """
        if self._usage:
            return self._usage

        if self.quota > 1:
            return f"<{self.name}>..."

        if self.choices:
            choices = "|".join(self.choices)
            res = f"<{self.name} " + "{" + choices + "}>"
        else:
            res = f"<{self.name}>"

        if self._profile == ZERO_OR_ONE:
            res = f"[{res}]"

        return res


class Flag(Option):
    """Data container representing a user-defined flag."""
    aliases = Aliases(is_flag=True)
    quota = Quota(minsize=0)

    def __init__(
            self,
            *aliases: str,
            dest: str = "",
            default: Any = None,
            const: Any = None,
            help: str = "",
            usage: str = "",
            is_global: bool = False,
            ):
        super().__init__(
            *aliases,
            quota=0,
            dest=dest,
            default=default,
            const=const,
            help=help,
            usage=usage,
            is_global=is_global,
        )

    @staticmethod
    def _coerce_quota(value) -> int:
        return value


class FastFlag(Flag):
    """Data container representing a user-defined fast flag."""
    _is_fast = True

    def __init__(
            self,
            *aliases: str,
            callback: Callable,
            help: str = "",
            usage: str = "",
            ):
        super().__init__(*aliases, help=help, usage=usage)
        self.callback = callback


class _OptionGroup:
    """
    An option group is a simple container class for storing options. Option
    groups can be used to group options that share similar characterstics or
    which are always expected to be added together to a command object.
    Options stored in a group can be added to a command by adding the entire
    group. Option groups help reduce code repetition and facilitate code re-use.
    """

    def __init__(self, parent: Optional[_OptionGroup] = None):
        self._parent = parent
        if parent is None:
            self._global_opts = Polymap()
        else:
            self._global_opts = self._parent._global_opts

        self._local_opts = Polymap()
        self._opts = ChainMap(self._local_opts, self._global_opts)
        self._dependent_keys = SetFamily()
        self._mutex_keys = SetFamily()

    @cached_property
    def local_options(self) -> MappingView:
        """A dictionary-like view containing all local options."""
        return MappingView(self._local_opts)

    @cached_property
    def global_options(self) -> MappingView:
        """A dictionary-like view containing all global options."""
        return MappingView(self._global_opts)

    @cached_property
    def options(self) -> MappingView:
        """
        A context-dependent, dictionary-like view containing all global and
        local options.
        """
        return MappingView(self._opts)

    def add_option(
            self,
            *aliases: str,
            dest: str = "",
            quota: int | str = 1,
            choices: Sequence[str] = tuple(),
            default: Any = None,
            const: Any = None,
            dtype: Optional[Callable] = None,
            action: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            required: bool = False,
            is_global: bool = False,
            ) -> None:
        """
        Add a non-positional option to the group.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        quota : {`int`, '+', '*'}, default 1
            The number of arguments which the parser will attempt to consume.

            - ``int``: Consume exactly ``quota`` arguments.
            - *: Consume zero or more arguments (greedy).
            - +: Consume one or more arguments (greedy).
        choices : `Sequence`
            An iterable containing the set of allowed strings for the parser
            to consume. Duplicates will be removed. A choice can be any
            string which does not contain a leading dash. This argument is
            only supported if ``quota`` is equal to one.
        default : `Any`, optional
            Default value used if the option is NOT encountered while parsing.
            Defaults are only supported by options which accept one or fewer
            arguments. If no default is supplied to an option with a quota of
            zero-or-more (*) then the value returned by the parser will be an
            empty list. Defaults are ignored for options which are members of
            mutually exclusive groups.
        const : `Any`, optional
            Default value used if the option IS encountered while parsing.
            ``const`` is only used in the case where an option expects one or
            fewer arguments but no arguments are consumed. If ``const`` is
            supplied to an option with a quota of zero-or-more (*) then the
            value returned by the parser will be an empty list.
        dtype : `Callable`, optional
            Optional callable which will be used to convert each of the tokens
            collected by the parser. Exceptions raised by this callback are not
            captured by ``clipp``.
        action : `Callable`, optional
            Optional callable for post-processing tokens collected by the
            parser. For options which only consume a single token, the list
            of tokens is indexed and the retrieved value is passed to the
            callable. Otherwise, ``action`` will receive the entire list. The
            action is always called after tokens have been converted by
            calling ``dtype``. Like ``dtype``, exceptions raised by this
            callback are not captured by ``clipp``.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.
        is_global : `bool`, default `False`
            Whether or not the option can be used in a sub-command.
            Sub-commands can override global options of their parents.

        Raises
        ------
        ``ValueError`` :
            - ``alias`` is not a valid short or long alias string.
            - ``quota`` is a string which is not equal to one of {'*', '+'}.
            - ``const`` or ``default`` are not supported, given the quota.
            - ``choices`` contains an invalid choice string.
            - ``choices`` is not supported, given the quota.
        ``TypeError`` :
            ``quota`` is not a numeric type or a string type.
        """
        opt = Option(
            *aliases,
            dest=dest,
            quota=quota,
            choices=choices,
            default=default,
            const=const,
            dtype=dtype,
            action=action,
            help=help,
            usage=usage,
            required=required,
            is_global=is_global,
        )
        self._add_option(opt)

    def add_flag(
            self,
            *aliases: str,
            dest: str = "",
            default: Any = None,
            const: Any,
            help: str = "",
            usage: str = "",
            is_global: bool = False,
            ) -> None:
        """
        Add a flag to the group.

        The parser does not evaluate command-line arguments for flags.
        Instead, their values are predetermined by their ``const`` and
        ``default`` values.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        default : `Any`, optional
            Default value used if the option is NOT encountered while parsing.
        const : `Any`
            Default value used if the option IS encountered while parsing.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.
        is_global : `bool`, default `False`
            Whether or not the option can be used in a sub-command.
            Sub-commands can override universal options of their parents.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        opt = Flag(
            *aliases,
            dest=dest,
            default=default,
            const=const,
            help=help,
            usage=usage,
            is_global=is_global,
        )
        self._add_option(opt)

    def add_binary_flag(
            self,
            *aliases,
            dest: str = "",
            const: bool = True,
            help: str = "",
            usage: str = "",
            is_global: bool = False,
            ) -> None:
        """
        Add a boolean flag to the group.

        The parser does not evaluate command-line arguments for boolean flags.
        Instead, their values are predetermined by ``const`` which expects a
        boolean value and is used to determine the option's default value
        which is always the opposite of ``const``. Thus, if ``const`` is
        ``True``, the default will be ``False``.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        const : `bool`,
            Default value used if the option IS encountered while parsing.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.
        is_global : `bool`, default `False`
            Whether or not the option can be used in a sub-command.
            Sub-commands can override universal options of their parents.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        const = bool(const)
        opt = Flag(
            *aliases,
            dest=dest,
            const=const,
            default=not const,
            help=help,
            usage=usage,
            is_global=is_global,
        )
        self._add_option(opt)

    def add_fast_flag(
            self,
            *aliases: str,
            callback: Callable,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Add a fast flag to the group.

        When a fast flag is encountered by the parser, a call to the option's
        callback function is immediately triggered, followed by a call to
        ``sys.exit``.

        The default --help option is an example of a fast flag. When any of the
        aliases for the option are encountered by the parser, the help
        message is immediately displayed, all other options are ignored,
        and the system exits.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        callback : `Callable`
            The function which is called when the option is encountered by
            the pre-processor.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        opt = FastFlag(*aliases, callback=callback, help=help, usage=usage)
        self._add_option(opt)

    def _add_option(self, option: Option) -> None:
        self._check_options(option)
        if option.is_global:
            self._global_opts[option.aliases] = option
        else:
            self._local_opts[option.aliases] = option

    def _check_options(self, option: Option) -> None:
        # It is important that we check each of the option's aliases, because
        # although the option's name may be unique, it could have a
        # non-unique alias. Each alias must be unique.
        for key in option.aliases:
            if key in self._opts:
                raise KeyError(f"option '{key}' already exists")

    def remove(self, option_name: str) -> None:
        """
        Remove an option from the command.

        Parameters
        ----------
        option_name : `str`
            The name of the option to be removed. If the option has multiple
            aliases, the name can be any one of those aliases.

        Raises
        ------
        ``KeyError`` :
            ``name`` is recognized by the command.
        """
        # todo: break this out into separate function. We need one function
        #  for retrieving the option, and one for the removal logic. This way,
        #  subclasses only need to override the option retrieval method then
        #  call `super()._private_remove_method`.
        if option_name in self._opts:
            if option_name in self._local_opts:
                opt = self._local_opts.pop(option_name)
            else:
                opt = self._global_opts.pop(option_name)

            if opt.is_dependent:
                self._unbind(opt.name, is_mutex=False)

            # Options can be members of both a mutex group and a dependent
            # group.
            if opt.is_mutex:
                self._unbind(opt.name, is_mutex=True)
        else:
            raise KeyError(option_name)

    def _unbind(self, key: str, is_mutex: bool) -> None:
        if is_mutex:
            metagroup = self._mutex_keys
        else:
            metagroup = self._dependent_keys

        for group in metagroup.copy():
            if key in group:
                metagroup.remove(group)
                group = {k for k in group if k != key}
                if len(group) > 1:
                    metagroup.add(group)
                    continue

                remaining_key = group.pop()
                # The remaining key may still be a member of another
                # relational group.
                if remaining_key in metagroup:
                    continue
                elif is_mutex:
                    self._opts[remaining_key]._is_mutex = False
                else:
                    self._opts[remaining_key]._is_dependent = False

    def include(
            self,
            option_group: OptionGroup,
            aliases: Optional[Sequence[str]] = None,
            ) -> None:
        """
        Include options from another option group.

        Relational group membership is maintained if more than one option from
        either a dependent or mutually exclusive group is added. If only one
        option from a given relational group is added, that option loses its
        status as a member of the relational group. For instance, if the option
        group being included has a mutually exclusive group comprised of --foo
        and --bar, but only --bar is included, then --bar will lose its status
        as a mutually exclusive option. The same rule applies to dependent
        groups.

        Parameters
        ----------
        option_group : `OptionGroup`
            The group containing the options to be added.
        aliases : `list[str]`, optional.
            Optional list of aliases referring to the options which should be
            added. If no list is provided, all options will be added.

        Raises
        ------
        ``KeyError`` :
            One or more of the options already exists in the group or has an
            alias which conflicts with an option which has already been added.
        """
        if aliases:
            keys = {option_group._opts[value].name for value in aliases}
        else:
            keys = {opt.name for opt in option_group._opts.values()}

        for k in keys:
            opt = option_group._opts[k]
            self._add_option(opt)

        for keygroup in option_group._dependent_keys:
            keygroup = keys.intersection(keygroup)
            if len(keygroup) > 1:
                self._dependent_keys.add(keygroup)
            elif len(keygroup) == 1:
                self._opts[keygroup.pop()]._is_dependent = False
        for keygroup in option_group._mutex_keys:
            keygroup = keys.intersection(keygroup)
            if len(keygroup) > 1:
                self._mutex_keys.add(keygroup)
            elif len(keygroup) == 1:
                self._opts[keygroup.pop()]._is_mutex = False

    def make_dependent(self, *aliases: str) -> None:
        # todo: needs docstring
        options = [self._opts[name] for name in aliases]
        if not is_homogeneous([opt.is_global for opt in options]):
            raise RelationalIntegrityError(
                "dependent groups cannot contain both global and local options"
            )

        for opt in options:
            if opt.required:
                raise AmbiguityError(
                    f"option '{opt.name}' cannot be made dependent because it "
                    f"is a required option; make each option required instead"
                )

        self._add_relational_group(
            aliases,
            dest=self._dependent_keys,
            other=self._mutex_keys,
        )

    def make_mutually_exclusive(self, *aliases: str) -> None:
        # todo: needs docstring
        err_msg = "option %s cannot be made mutually exclusive because %s"
        options = [self._opts[name] for name in aliases]
        for opt in options:
            # if opt.has_default:
            #     raise AmbiguityError(
            #         err_msg % (opt.name, "it has a default value")
            #     )

            if opt.required:
                raise RelationalIntegrityError(
                    err_msg % (opt.name, "it is a required option")
                )

        self._add_relational_group(
            aliases,
            dest=self._mutex_keys,
            other=self._dependent_keys,
        )

    def _add_relational_group(
            self,
            aliases: str,
            dest: SetFamily,
            other: SetFamily,
            ) -> None:
        keys = {self._opts[value].name for value in aliases}
        if len(keys) < 2:
            raise ValueError(
                "mutually exclusive and dependent groups require more than "
                "one uniqe alias"
            )

        for k in keys:
            if self._opts[k]._is_fast:
                raise ValueError(
                    "fast flags cannot be made mutually exclusive or dependent"
                )

            if dest is self._dependent_keys:
                self._opts[k]._is_dependent = True
            else:
                self._opts[k]._is_mutex = True

        for group in other:
            conflicts = keys.intersection(group)
            if len(conflicts) > 1:
                conflicts = ", ".join(sorted(conflicts))
                raise RelationalIntegrityError(
                    f"opposing relational groups cannot have more than one "
                    f"option in common: {conflicts}"
                )

        dest.add(keys)


class OptionGroup(_OptionGroup):

    def __init__(self):
        super().__init__()


class _Command(_OptionGroup):
    """
    Container for storing user-defined options and sub-commands. Uses
    stored options and sub-commands to generate rules which dictate how
    command-line arguments are to be parsed.

    Parameters
    ----------
    name : `str`, optional
        The name of the command used as the key in the namespace returned
        after parsing command-line arguments. If no name is provided,
        defaults to the name of the script which calls the constructor.
    prologue : `str`, optional
        The introductory text displayed in the command's help message.
    epilogue : `str`, optional
        The text displayed at the bottom of the command's help message.
    usage : `str`, optional
        The usage text displayed in the command's help message.
    help : `str`, optional
        The help message which is displayed when user's invoke the help
        function by supplying the help option string in the terminal.
    version_info : `str`, optional
        The version info message which is displayed when user's invoke the
        version info function by supplying the version option string in the
        terminal.
    """
    name = ReadOnlyAttribute()

    def __init__(
            self,
            name: str = "",
            prologue: str = "",
            epilogue: str = "",
            usage: str = "",
            help: str = "",
            version_info: str = "",
            parent: Optional[_Command] = None,
            ):
        super().__init__(parent=parent)
        if name:
            self.name = name
        else:
            self.name = pathlib.Path(sys.argv[0]).name

        self.prologue = prologue
        self.epilogue = epilogue
        self.usage = usage
        self.help = help
        self.version_info = version_info

        self.subcommands = {}
        self._params = Polymap()
        self._namespaces = set()

        # Set in `__post_init__`.
        self.nsid = None
        self._help_flag = None
        self._version_flag = None

        self.__post_init__()

    @cached_property
    def parameters(self) -> MappingView:
        """A dictionary-like view containing all positional arguments."""
        return MappingView(self._params)

    def __post_init__(self) -> None:
        self._set_namespace_id()
        self._init_defaults()

    def _set_namespace_id(self) -> None:
        self._nsid = self.name
        self._namespaces.add(self.name)

    def _init_defaults(self) -> None:
        flag = FastFlag(
            "--help", "-h",
            callback=self._display_help,
            help="Display this help message.",
        )
        self._add_option(flag)
        self._help_flag = flag.name
        if self.version_info:
            flag = FastFlag(
                "--version",
                callback=self._display_version,
                help="Display version info.",
            )
            self._add_option(flag)
            self._version_flag = flag.name

    def _display_help(self) -> None:
        print(self.format_help())

    def _display_version(self) -> None:
        print(self.format_version_info())

    def add_subcommand(
            self,
            name: str,
            dest: str = "",
            prologue: str = "",
            epilogue: str = "",
            usage: str = "",
            help: str = "",
            version_info: str = "",
            ):
        """
        Add the specified sub-command identified by ``name`` to the command.

        Parameters
        ----------
        name : `str`
            The name of the sub-command. Unless overriden by ``dest``, it is
            used as the key in the dictionary/namespace produced by the parser.
        prologue : `str`, optional
            The introductory text displayed in the command's help message.
        epilogue : `str`, optional
            The text displayed at the bottom of the command's help message.
        usage : `str`, optional
            The usage text displayed in the command's help message.
        help : `str`, optional
            The help message which is displayed when user's invoke the
            help function by supplying the help option string in the terminal.
        version_info : `str`, optional
            The version info message which is displayed when user's invoke the
            version info function by supplying the version option string in the
            terminal.
        dest : `str`, optional
            The namespace ID used by to parser to avoid naming conflicts with
            other commands while generating the return namespace. If ``name``
            conflicts with the name of any other command in the command
            hierarchy, a unique ``dest`` must be provided.

        Raises
        ------
        ``KeyError`` :
            ``name`` interferes with the name of a another command in the
            command hierarchy and a non-unique ``dest`` has been supplied.
        """
        if name not in self.subcommands:
            command = Subcommand(
                parent=self,
                name=name,
                dest=dest,
                prologue=prologue,
                epilogue=epilogue,
                usage=usage,
                help=help,
                version_info=version_info,
            )
            self.subcommands[name] = command
            return command
        else:
            raise KeyError(f"sub-command '{name}' already exists")

    def add_parameter(
            self,
            name: str,
            dest: str = "",
            quota: int | str = 1,
            choices: Sequence[str] = tuple(),
            default: Any = None,
            dtype: Optional[Callable] = None,
            action: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Add a positional argument to the command.

        Parameters
        ----------
        name : `str`
            The namespace ID for the argument. Positional argument names may
            contain only letters, numbers, and dashes (-). Leading or
            trailing dashes are disallowed.
        dest : `str`, optional
            Alternative name for the argument, used as the argument's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        quota : {`int`, '+', '*'}, default 1
            The number of arguments which the parser will attempt to consume.

            - ``int``: Consume exactly ``quota`` arguments.
            - *: Consume zero or more arguments (greedy).
            - +: Consume one or more arguments (greedy).
            - ?: Consume zeror or exactly one argument.
        choices : `Sequence`
            An iterable containing the set of allowed strings for the parser
            to consume. There must be more than one choice. Duplicates will be
            removed. A choice can be any string which does not contain a
            leading dash. This parameter is only supported if ``quota`` is
            equal to one or '?'.
        default : `Any`, optional
            Default value used if the option is NOT encountered while parsing.
            Defaults are only supported by options which accept one or fewer
            arguments. If no default is supplied to an option with a quota of
            zero-or-more (*) then the value returned by the parser will be an
            empty list.
        dtype : `Callable`, optional
            Optional callable which will be used to convert each of the tokens
            collected by the parser. Exceptions raised by this callback are not
            captured by ``clipp``.
        action : `Callable`, optional
            Optional callable for post-processing tokens collected by the
            parser. For options which only consume a single token, the list
            of tokens is indexed and the retrieved value is passed to the
            callable. Otherwise, ``action`` will receive the entire list. The
            action is always called after tokens have been converted by
            calling ``dtype``. Like ``dtype``, exceptions raised by this
            callback are not captured by ``clipp``.
        help : `str`, optional
            The argument's help string which defines its usage.
        usage : `str`, optional
            The argument's usage string which defines its syntax. If no
            string is provided, ``clipp`` will attempt to infer the syntax.

        Raises
        ------
        ``ValueError`` :
            - ``name`` is not a valid positional argument name.
            - ``quota`` is a string which is not equal to one of
              {'*', '+', '?'}.
            - ``default`` is not supported, given the quota.
            - ``choices`` contains an invalid choice string.
            - ``choices`` is not supported, given the quota.
        ``TypeError`` :
            ``quota`` is not a numeric type or a string type.
        """
        opt = Parameter(
            name,
            dest=dest,
            quota=quota,
            choices=choices,
            default=default,
            dtype=dtype,
            action=action,
            help=help,
            usage=usage,
        )
        self._add_parameter(opt)

    def _add_parameter(self, value: Parameter) -> None:
        self._check_options(value)
        if self._params:
            last = index_view(self._params.values(), -1)
            if last.quota == INF or last._profile == ZERO_OR_ONE:
                raise AmbiguityError(
                    f"the quota for positional argument '{value.name}' "
                    f"is ambiguous because it follows a positional argument "
                    f"with a variable quota"
                )

        self._params[value.aliases] = value

    def _check_options(self, value: Option) -> None:
        for key in value.aliases:
            if key in self._params or key in self._opts:
                raise KeyError(f"option alias '{key}' already exists")

    def remove(self, option_name: str) -> None:
        """
        Remove an option or parameter from the command.

        Parameters
        ----------
        option_name : `str`
            The name of the option to be removed. If the option has multiple
            aliases, the name can be any one of those aliases.

        Raises
        ------
        ``KeyError`` :
            ``name`` is recognized by the command.
        """
        if option_name in self._opts:
            if option_name in self._local_opts:
                opt = self._local_opts.pop(option_name)
            else:
                opt = self._global_opts.pop(option_name)

            if opt.is_dependent:
                self._unbind(opt.name, is_mutex=False)

            if opt.is_mutex:
                self._unbind(opt.name, is_mutex=True)

            if opt.name == self._help_flag:
                self._help_flag = None
            elif opt.name == self._version_flag:
                self._version_flag = None
        elif option_name in self._params:
            del self._params[option_name]
        else:
            raise KeyError(option_name)

    def set_help_flag(
            self,
            *aliases: str,
            callback: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Set the default help flag. If a help flag has already been set,
        it will be overridden.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        callback : `Callable`
            The function which is called when the option is encountered by
            the pre-processor.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        if self._help_flag:
            self.remove(self._help_flag)

        if callback is None:
            callback = self._display_help

        flag = FastFlag(*aliases, callback=callback, help=help, usage=usage)
        self._add_option(flag)
        self._help_flag = flag.name

    def set_version_flag(
            self,
            *aliases: str,
            callback: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Set the default version info flag. If the flag has already been set,
        it will be overridden.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        callback : `Callable`
            The function which is called when the option is encountered by
            the pre-processor.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        if self._version_flag:
            self.remove(self._version_flag)

        if callback is None:
            callback = self._display_version

        flag = FastFlag(*aliases, callback=callback, help=help, usage=usage)
        self._add_option(flag)
        self._version_flag = flag.name

    def format_version_info(self) -> str:
        """Formats and returns the command's version info string."""
        return fill_paragraph(self.version_info)

    def format_help(self) -> str:
        """
        Formats and returns the option's help string.

        If a help string was explicitly supplied to the command, that is the
        string which is formatted. Otherwise, ``clipp`` will compile and format
        its own help string.
        """
        if self.help:
            return fill_paragraph(self.help)

        sections = []
        if self.prologue:
            sections.append(fill_paragraph(self.prologue))

        sections.append(self.format_usage())
        if self.subcommands:
            keys = sorted(self.subcommands.keys())
            cmd_section = "Commands: "
            cmd_section += "{" + " | ".join(keys) + "}"
            cmd_section = fill_paragraph(cmd_section, subsequent_indent=RJUST)
            sections.append(cmd_section)

        if self._params:
            values = self._params.values()
            pos_section = "Positional Arguments:\n"
            pos_section += "\n".join(v.format_help() for v in values)
            sections.append(pos_section)

        if self._opts:
            values = sorted(self._opts.values(), key=lambda x: x.name)
            opt_section = "Options:\n"
            opt_section += "\n".join(v.format_help() for v in values)
            sections.append(opt_section)

        if self.epilogue:
            sections.append(fill_paragraph(self.epilogue))

        return "\n\n".join(sections)

    def format_usage(self) -> str:
        """
        Formats and returns the command's usage string.

        If a usage string was explicitly provided, it is wrapped to the width
        of the terminal and returned.
        """
        # todo: need to find a way to join usages for flags which only have
        #  short aliases (i.e. [-vrp]).
        if self.usage:
            return fill_paragraph(self.usage)

        to_format = []
        free_opts = [
            opt for opt in sorted(self._opts.values(), key=lambda x: x.name)
            if opt.is_dependent + opt.is_mutex == 0
        ]
        # Append positional arguments.
        to_format.extend([
            param.usage.replace(" ", "_")
            for param in self._params.values()
        ])
        # Append required options.
        to_format.extend([
            opt.usage.replace(" ", "_")
            for opt in free_opts if opt.required
        ])
        # Append non-required options.
        to_format.extend([
            opt.usage.replace(" ", "_")
            for opt in free_opts if not opt.required
        ])
        # Append options from relational groups.
        for group in self._dependent_keys:
            section = self._join_group_usages(group, delimiter=" ")
            to_format.append(f"({section})")
        for group in self._mutex_keys:
            section = self._join_group_usages(group, delimiter=" | ")
            to_format.append("{" + section + "}")

        if self.subcommands:
            if len(self.subcommands) > 1:
                section = "[<command> [<args>]]"
            else:
                command = next(iter(self.subcommands.values())).name
                section = f"[<{command}> [<args>]]"

            to_format.append(section)

        usage = " ".join(to_format)
        prefix = f"Usage: {self.name}"
        too_long = len(prefix) > LPAD - 4
        if too_long:
            prefix, name = prefix.split(" ")
            prefix += "\n"
            indent = " " * len(prefix)
            usage = f"{name} {usage}"
            usage = prefix + fill_paragraph(
                usage,
                initial_indent=indent,
                subsequent_indent=indent,
            )
        else:
            prefix += " "
            indent = " " * len(prefix)
            usage = prefix + usage
            usage = fill_paragraph(usage, subsequent_indent=indent)

        usage = usage.replace("_|_", " | ").replace("_", " ")
        return usage

    def _join_group_usages(self, group: frozenset, delimiter: str) -> str:
        # Join the usage strings for each group in the relational group by the
        # appropriate delimiter.
        names = sorted(group, key=lambda name: (-len(name), name))
        return delimiter.join(self._opts[k].usage for k in group)

    def _check_relational_groups(self, namespace: dict[str, list[Any]]) -> None:
        keys = {k for k in namespace.keys() if k not in self._params}
        for k in keys:
            group = self._dependent_keys.includes(k, superset=True)
            diff = group.difference(keys)
            if diff:
                needs = ", ".join(sorted(diff))
                sys.exit(f"ERROR: option {k} requires: {needs}")

            group = self._mutex_keys.includes(k, superset=True)
            conflicts = group.intersection(keys)
            if len(conflicts) > 1:
                conflicts = ", ".join(sorted(conflicts))
                sys.exit(f"ERROR: conflicting options supplied: {conflicts}")

    def _check_required(
            self,
            namespace: dict[str, list[Any]],
            is_global: bool,
            ) -> None:
        if is_global:
            required = (
                opt for opt in self._opts.values()
                if opt.required and opt.is_global
            )
        else:
            required = (
                opt for opt in chain(self._params.values(), self._opts.values())
                if opt.required and not opt.is_global
            )

        for opt in required:
            if opt.name not in namespace:
                sys.exit(f"ERROR: missing option {opt.name}")

    def _get_local_namespace(self) -> dict[str, Any]:
        namespace = {}
        params = self._params.values()
        options = (
            v for v in self._opts.values()
            if not v._is_fast and not v.is_global
        )
        for opt in chain(params, options):
            if opt.has_default:
                namespace[opt.altname] = opt.default

        return namespace

    def _get_global_namespace(self) -> dict[str, Any]:
        namespace = {}
        options = (v for v in self._opts.values() if v.is_global)
        for opt in options:
            if opt.has_default:
                namespace[opt.altname] = opt.default

        return namespace

    def _preprocess(
            self,
            arguments: list[str],
            ) -> tuple[Command | Subcommand, deque[str]]:
        cmd = self
        subcmds = cmd.subcommands
        lower_bound = 0
        for idx, arg in enumerate(arguments):
            if arg in subcmds:
                yield cmd, deque(arguments[lower_bound:idx])
                cmd = subcmds[arg]
                subcmds = cmd.subcommands
                lower_bound = idx + 1
                if not subcmds:
                    break

        yield cmd, deque(arguments[lower_bound:])

    def _postprocess(
            self,
            namespace: dict[str, list[Any]],
            is_global: bool,
            ) -> dict[str, Any]:
        self._check_relational_groups(namespace)
        self._check_required(namespace, is_global=is_global)
        processed = {}
        for key, values in namespace.items():
            if key in self._opts:
                opt = self._opts[key]
            else:
                opt = self._params[key]

            opt._validate(values)
            if not values and isinstance(opt, Parameter):
                return processed

            if not values and opt.has_const:
                processed[opt.altname] = opt.const
            elif opt.quota == 1:
                processed[opt.altname] = opt.action(values[0])
            else:
                processed[opt.altname] = opt.action(values)

        return processed

    _postprocess_locals = partialmethod(_postprocess, is_global=False)
    _postprocess_globals = partialmethod(_postprocess, is_global=True)

    def parse(self, arguments: Optional[list[str]] = None) -> Namespace:
        if arguments is None:
            arguments = sys.argv[1:]

        extra = []
        gns = self._get_global_namespace()
        lns = {}
        for cmd, args in self._preprocess(arguments):
            parser = Parser(cmd)
            processed, unconsumed = parser.parse(args)
            child = cmd._get_local_namespace()
            child.update(cmd._postprocess_locals(processed.locals))
            gns.update(cmd._postprocess_globals(processed.globals))
            lns[cmd._nsid] = child
            extra.extend(unconsumed)

        return Namespace(gns, lns, extra)


class Command(_Command):

    def __init__(
            self,
            name: str = "",
            prologue: str = "",
            epilogue: str = "",
            usage: str = "",
            help: str = "",
            version_info: str = "",
            ):
        super().__init__(name, prologue, epilogue, usage, help, version_info)


class Subcommand(_Command):
    # The name of the parent command isn't ever evaluated by the parser or
    # the pre-processor, but for sub-commands, the name is processed,
    # so it must be a valid positional name which cannot be misidentified as a
    # flag.
    name = PositionalName()

    def __init__(
            self,
            *args,
            parent: _Command,
            dest: Optional[str] = None,
            **kwargs,
            ):
        self._dest = dest
        super().__init__(*args, parent=parent, **kwargs)

    def _set_namespace_id(self) -> None:
        nsid = self._dest if self._dest else self.name
        if nsid in self._parent._namespaces:
            raise KeyError(f"non-unique namespace ID: {nsid}")

        self._namespaces.add(nsid)
        self._nsid = nsid

    def add_option(
            self,
            *aliases: str,
            dest: str = "",
            quota: int | str = 1,
            choices: Sequence[str] = tuple(),
            default: Any = None,
            const: Any = None,
            dtype: Optional[Callable] = None,
            action: Optional[Callable] = None,
            help: str = "",
            usage: str = "",
            required: bool = False,
            ) -> None:
        """
        Add a non-positional option to the group.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        quota : {`int`, '+', '*'}, default 1
            The number of arguments which the parser will attempt to consume.

            - ``int``: Consume exactly ``quota`` arguments.
            - *: Consume zero or more arguments (greedy).
            - +: Consume one or more arguments (greedy).
        choices : `Sequence`
            An iterable containing the set of allowed strings for the parser
            to consume. Duplicates will be removed. A choice can be any
            string which does not contain a leading dash. This argument is
            only supported if ``quota`` is equal to one.
        default : `Any`, optional
            Default value used if the option is NOT encountered while parsing.
            Defaults are only supported by options which accept one or fewer
            arguments. If no default is supplied to an option with a quota of
            zero-or-more (*) then the value returned by the parser will be an
            empty list. Defaults are ignored for options which are members of
            mutually exclusive groups.
        const : `Any`, optional
            Default value used if the option IS encountered while parsing.
            ``const`` is only used in the case where an option expects one or
            fewer arguments but no arguments are consumed. If ``const`` is
            supplied to an option with a quota of zero-or-more (*) then the
            value returned by the parser will be an empty list.
        dtype : `Callable`, optional
            Optional callable which will be used to convert each of the tokens
            collected by the parser. Exceptions raised by this callback are not
            captured by ``clipp``.
        action : `Callable`, optional
            Optional callable for post-processing tokens collected by the
            parser. For options which only consume a single token, the list
            of tokens is indexed and the retrieved value is passed to the
            callable. Otherwise, ``action`` will receive the entire list. The
            action is always called after tokens have been converted by
            calling ``dtype``. Like ``dtype``, exceptions raised by this
            callback are not captured by ``clipp``.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.

        Raises
        ------
        ``ValueError`` :
            - ``alias`` is not a valid short or long alias string.
            - ``quota`` is a string which is not equal to one of {'*', '+'}.
            - ``const`` or ``default`` are not supported, given the quota.
            - ``choices`` contains an invalid choice string.
            - ``choices`` is not supported, given the quota.
        ``TypeError`` :
            ``quota`` is not a numeric type or a string type.
        """
        opt = Option(
            *aliases,
            dest=dest,
            quota=quota,
            choices=choices,
            default=default,
            const=const,
            dtype=dtype,
            action=action,
            help=help,
            usage=usage,
            required=required,
        )
        self._add_option(opt)

    def add_flag(
            self,
            *aliases: str,
            dest: str = "",
            default: Any = None,
            const: Any,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Add a flag to the group.

        The parser does not evaluate command-line arguments for flags.
        Instead, their values are predetermined by their ``const`` and
        ``default`` values.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        default : `Any`, optional
            Default value used if the option is NOT encountered while parsing.
        const : `Any`
            Default value used if the option IS encountered while parsing.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        opt = Flag(
            *aliases,
            dest=dest,
            default=default,
            const=const,
            help=help,
            usage=usage,
        )
        self._add_option(opt)

    def add_binary_flag(
            self,
            *aliases,
            dest: str = "",
            const: bool = True,
            help: str = "",
            usage: str = "",
            ) -> None:
        """
        Add a boolean flag to the group.

        The parser does not evaluate command-line arguments for boolean flags.
        Instead, their values are predetermined by ``const`` which expects a
        boolean value and is used to determine the option's default value
        which is always the opposite of ``const``. Thus, if ``const`` is
        ``True``, the default will be ``False``.

        Parameters
        ----------
        *aliases : `str`
            The various aliases which can be used to invoke the option from the
            command-line.
        dest : `str` optional
            Alternative name for the option, used as the option's key in the
            namespace produced after parsing command-line arguments. If two
            or more options have the same ``dest``, they will clobber each
            other in the namespace, which may or may not be desired.
        const : `bool`,
            Default value used if the option IS encountered while parsing.
        help : `str`, optional
            The option's help string which defines its usage.
        usage : `str`, optional
            The option's usage string which defines its syntax. If no string is
            provided, ``clipp`` will attempt to infer the syntax.
        required : `bool`, default `False`
            Whether or not the option is a required option.

        Raises
        ------
        ``ValueError`` :
            ``alias`` is not a valid short or long alias string.
        """
        const = bool(const)
        opt = Flag(
            *aliases,
            dest=dest,
            const=const,
            default=not const,
            help=help,
            usage=usage,
        )
        self._add_option(opt)

    def _add_option(self, value: Option) -> None:
        # If we allow users to add global options to sub-commands, they may
        # be surprised to find that they cannot remove a global option from a
        # sub-command. Although users cannot supply `is_global` to any of the
        # `add_...` methods, they could still attempt to add a global option
        # via a group.
        if value.is_global:
            raise ValueError("cannot add global options to sub-commands")

        super()._add_option(value)

    def _check_options(self, value: Option) -> None:
        for key in value.aliases:
            if key in self._params or key in self._local_opts:
                raise KeyError(f"option '{key}' already exists")

    def remove(self, option_name: str) -> None:
        """
        Remove an option or parameter from the command.

        Parameters
        ----------
        option_name : `str`
            The name of the option to be removed. If the option has multiple
            aliases, the name can be any one of those aliases.

        Raises
        ------
        ``KeyError`` :
            No option with ``name`` is recognized by the command.
        """
        # Only allow removal of local options in sub-commands. This is not a
        # constraint which is imposed by the spec. Instead, this decision is
        # deliberate, and is meant to help avoid confusion.
        if option_name in self._local_opts:
            opt = self._local_opts.pop(option_name)
            if opt.is_dependent:
                self._unbind(opt.name, is_mutex=False)

            if opt.is_mutex:
                self._unbind(opt.name, is_mutex=True)

            if opt.name == self._help_flag:
                self._help_flag = None
            elif opt.name == self._version_flag:
                self._version_flag = None
        elif option_name in self._params:
            del self._params[option_name]
        else:
            raise KeyError(option_name)


class Parser:
    """
    Parser object for parsing command-line arguments for a given command.

    Parameters
    ----------
    command : {`Command`, `Subcommand`}
        The command which informs the parser how to parse the argument stack.
    """

    def __init__(self, command: Command | Subcommand):
        self.command = command

    @staticmethod
    def _throw_unknown_option_error(token: str) -> None:
        sys.exit(f"ERROR: unknown option '{token}'")

    def _decompose_long(self, token: str) -> tuple[str]:
        temp = ""
        options = self.command._opts
        for idx, char in enumerate(token):
            temp += char
            # A single dash is a valid option alias which could be in the
            # options dictionary, so we must ignore the case in which `temp`
            # is a single dash. Since long options must have at least four
            # characters, we don't check `temp` against the options table
            # until `temp` is at least four characters long. This effectively
            # solves the single dash problem and avoids premature membership
            # testing.
            if idx >= 3 and temp in options:
                # Tokens need to be reversed for call to `extendleft`.
                return "".join(token[idx + 1:]), temp
        else:
            self._throw_unknown_option_error(token)

    def _decompose_short(self, token: str) -> list[str]:
        stack = []
        nonzero_quota = False
        options = self.command._opts
        for idx, char in enumerate(token[1:], start=1): # Ignore leading dash.
            if nonzero_quota:
                # The last found option accepts arguments; we must treat the
                # remainder of the token as an argument.
                stack.insert(0, token[idx:])
                break

            assumed_opt = "-" + char
            if assumed_opt not in options:
                self._throw_unknown_option_error(token)
            else:
                opt = options[assumed_opt]
                if opt.quota > 0:
                    nonzero_quota = True

            stack.insert(0, assumed_opt)

        return stack

    def parse(self, arguments: deque[str]) -> tuple[ParsedArguments, list]:
        options = self.command._opts
        lopts = {} # Local option namespace.
        gopts = {} # Global option namespace.
        params = []
        esc = ESC
        while arguments:
            token = arguments.popleft()
            if token[0] != "-":
                params.append(token)
            elif token in options:
                opt = options[token]
                if opt._is_fast:
                    opt.callback()
                    sys.exit()

                if not opt.is_global:
                    processed = lopts
                else:
                    processed = gopts

                values = processed.get(opt.name, [])
                while arguments and len(values) < opt.quota:
                    token = arguments.popleft()
                    if token == esc or token[0] == "-" and not is_number(token):
                        # Either we've hit an escape sequence, or the token
                        # is a string which can only be interpreted as an
                        # option. Put the token back on the stack and bail.
                        arguments.appendleft(token)
                        break

                    values.append(opt.convert(token))

                processed[opt.name] = values
            elif token.startswith("--"):
                if token == esc:
                    break
                elif "=" in token:
                    new_tokens = reversed(token.split("=", 1))
                    arguments.extendleft(new_tokens)
                else:
                    new_tokens = self._decompose_long(token)
                    arguments.extendleft(new_tokens)
            elif not is_number(token):
                new_tokens = self._decompose_short(token)
                arguments.extendleft(new_tokens)
            else:
                params.append(token)

        params += arguments
        for opt in self.command._params.values():
            if opt.quota != INF:
                lopts[opt.name] = [opt.convert(v) for v in params[:opt.quota]]
                del params[:opt.quota]
            else:
                lopts[opt.name] = [opt.convert(v) for v in params]
                del params[:]

        return ParsedArguments(gopts, lopts), params
