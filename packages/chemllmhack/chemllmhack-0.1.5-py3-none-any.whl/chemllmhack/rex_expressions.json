{
  "help_info": "Rex is the official language for RUSH platform\n\nMath\nYou can write mathematical expressions intuitively, and they will follow the usual operator precedence:\nw + x * y + z\n\n\nFunction Calls\nYou can call functions by naming them and listing their arguments (white-space separated). For example, assuming a function called auto3D:\nauto3D x y z\n\nTo pass the result of one function into another, use parentheses to ensure the correct order:\nexess a b (auto3D x y z)\nThis passes three arguments to the exess function, with the third being the result of auto3D x y z.\n\nCommon Mistake\nAvoid dropping the parentheses:\nexess a b auto3D x y z\nThis tries to call exess with six arguments, the third being the auto3D function itself, not its result. This causes type errors.\n\nCalling Operators Like Functions\nYou can use math operators in a function-like manner by surrounding them with parentheses:\n(+) x y\n\nCurrying (Partially Calling a Function)\nIn Rex, if a function takes N arguments, you do not have to provide all N arguments at once. It is acceptable to pass fewer:\n(*) 2\nThis returns a new function that waits for more arguments. This is how all functions are called in Rex. Whitespace is left associative, meaning f x y z is equivalent to (((f x) y) z).\n\nMapping\nTo apply a function to a list of values, use the map function:\nmap ((*) 2) [1, 2, 3]\nThis doubles each item in the list, resulting in [2, 4, 6].\n\nFirst Supercomputing Module\nauto3D r1 o1 (map smi list_of_smols)\nThis extracts the SMILES string from each Smol entity in list_of_smols and calls auto3D with those SMILES as inputs. The result is a list of auto3D outputs for each Smol entity.\n\nProtein Preparation\nmap (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins\nThis extracts the FASTA sequence from each protein, runs a multiple sequence alignment, and uses it for colabfold. The output is a list of predicted structures for each input protein.\n\nPocket Prediction\np2rank r4 o4 list_of_conformers\nThis pattern continues, showing a similar usage for pocket prediction.\n\nPutting It Together\nCombine these functions:\ngnina r5 o5 \n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n  (p2rank r4 o4 (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins))\n  (flatten (auto3D r1 o1 (map smi list_of_smols)))\n\nThis calls gnina for every small molecule against every binding site for every protein. However, this is inefficient as it runs mmseqs2 and colabfold twice. Improve efficiency using a lambda:\n(\\ps ->\n  gnina r5 o5 \n    ps\n    (p2rank r4 o4 ps)\n    (flatten (auto3D r1 o1 (map smi list_of_smols))))\n  (map (colabfold r3 o3 . mmseqs2 r2 o2 . seq) list_of_proteins)\n\nThis runs the sequence alignment and folding functions once, assigns it to ps, and re-uses ps.\n\n(Note: Rex is capable of not recomputing identical expressions, but using a lambda is good practice to simplify changes.)",
  "prepare_protein": "prepared_protein = (get \"Ok\" (get 0 (await (get 1 \n    ( prepare_protein_rex\n      (json '{\"resources\":{\"cpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet\"}')\n      (arg (json '{}'))\n      (arg [[ (upload (json protein_sequence)) ]])\n    )\n  ))))",
  "auto3d": "(get \"Ok\" (get 0 (await (get 1 \n    ( auto3d_rex\n      (json '{\"resources\":{\"gpus\":1,\"storage\":10,\"storage_units\":\"MB\"},\"target\":\"Bullet2\"}')\n      (arg (json '{\"k\":1}'))\n      (arg smiles)\n    )\n  ))))",
  "p2rank": "p2rank_rex_template",
  "gnina": "gnina_rex_template",
  "colabfold": "colabfold_rex_template"
}