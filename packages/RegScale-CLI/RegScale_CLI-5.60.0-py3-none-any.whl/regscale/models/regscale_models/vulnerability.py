#!/usr/bin/env python3
# -*- coding: utf-8 -*-
""" Model for Vulnerability in the application """
import logging
from typing import List, Optional, Union
from urllib.parse import urljoin

from pydantic import ConfigDict, Field
from requests import Response

from regscale.core.app.api import Api
from regscale.core.app.application import Application
from regscale.core.app.logz import create_logger
from regscale.core.app.utils.app_utils import get_current_datetime
from regscale.models.regscale_models.regscale_model import RegScaleModel


class Vulnerability(RegScaleModel):
    """Vulnerability Model"""

    _module_slug = "vulnerability"

    id: int = 0
    createdById: str = Field(default_factory=RegScaleModel._api_handler.get_user_id)
    dateCreated: str = Field(default_factory=get_current_datetime)
    lastUpdatedById: str = Field(default_factory=RegScaleModel._api_handler.get_user_id)
    dateLastUpdated: str = Field(default_factory=get_current_datetime)
    uuid: Optional[str] = None
    scanId: Optional[int] = Field(None, alias="scan_id")
    parentId: Optional[int] = Field(None, alias="parent_id")
    parentModule: Optional[str] = Field(None, alias="parent_module")
    lastSeen: Optional[str] = Field(None, alias="last_seen")
    firstSeen: Optional[str] = Field(None, alias="first_seen")
    daysOpen: Optional[int] = Field(None, alias="days_open")
    dns: Optional[str] = None
    ipAddress: Optional[str] = Field(None, alias="ip_address")
    mitigated: Optional[bool] = None
    operatingSystem: Optional[str] = Field(None, alias="operating_system")
    port: Optional[Union[str, int]] = None
    protocol: Optional[str] = None
    severity: Optional[str] = None
    plugInName: Optional[str] = Field(None, alias="plugin_name")
    plugInId: Optional[int] = Field(None, alias="plugin_id")
    cve: Optional[str] = None
    vprScore: Optional[Union[int, float]] = Field(None, alias="vpr_score")
    exploitAvailable: Optional[bool] = Field(None, alias="exploit_available")
    title: Optional[str] = None
    cvsSv3BaseScore: Optional[Union[float, int]] = Field(None, alias="cvss_v3_base_score")
    description: Optional[str] = None
    plugInText: Optional[str] = Field(None, alias="plugin_text")
    tenantsId: int = Field(0, alias="tenants_id")

    @staticmethod
    def _get_additional_endpoints() -> ConfigDict:
        """
        Get additional endpoints for the Vulnerability model, using {model_slug} as a placeholder for the model slug.

        :return: A dictionary of additional endpoints
        :rtype: ConfigDict
        """
        return ConfigDict(  # type: ignore
            get_all_by_parent="/api/{model_slug}/getAllByParent/{intParentID}",
            get_count="/api/{model_slug}/getCount",
            batch_create="/api/{model_slug}/batchCreate",
            find_by_guid="/api/{model_slug}/findByGUID/{strGUID}",
            drilldown="/api/{model_slug}/drilldown/{parentId}/{scanId}/{strSeverity}/{intPage}/{intPageSize}",
            lookup_cve="/api/{model_slug}/lookupCVE/{strCVE}",
        )

    def __hash__(self) -> hash:
        """
        Enable object to be hashable

        :return: Hashed Vulnerability
        :rtype: hash
        """
        return hash(
            (
                self.title,
                self.scanId,
                self.ipAddress,
                self.parentModule,
                self.parentId,
                self.uuid,
            )
        )

    def __eq__(self, other: "Vulnerability") -> bool:
        """
        Enable object to be equal

        :param Vulnerability other: Vulnerability Object to compare to
        :return: Whether the Vulnerability objects are equal
        :rtype: bool
        """
        return (
            self.title == other.title
            and self.scanId == other.scanId
            and self.ipAddress == other.ipAddress
            and self.parentModule == other.parentModule
            and self.parentId == other.parentId
            and self.uuid == other.uuid
        )

    @classmethod
    def logger(cls) -> logging.Logger:
        """
        Logger for Vulnerability Model

        :return: Logger
        :rtype: logging.Logger
        """
        logger = create_logger()
        return logger

    @staticmethod
    def find_vulns_by_scan(app: Application, scan_id: int) -> List["Vulnerability"]:
        """
        Find Vulnerabilities by Scan ID

        :param Application app: Application instance
        :param int scan_id: Scan ID
        :return: List of Vulnerabilities
        :rtype: List[Vulnerability]
        """
        api = Api(app)
        api_url = urljoin(app.config.get("domain"), f"/api/vulnerability/getAllByParent/{scan_id}")
        response = api.get(url=api_url, params={"scanId": scan_id})
        if response.ok:
            return [Vulnerability(**v) for v in response.json()]
        response.raise_for_status()
        return []

    @staticmethod
    def determine_cvss3_severity_text(cvs_sv3_base_score: float) -> str:
        """
        Determine CVSS3 Severity Text from CVSS3 Base Score

        :param float cvs_sv3_base_score: CVSS3 Base Score
        :return: CVSS3 Severity Text
        :rtype: str
        """
        results = "low"
        if 4.0 <= cvs_sv3_base_score <= 6.9:
            results = "medium"
        elif 7.0 <= cvs_sv3_base_score <= 8.9:
            results = "high"
        elif cvs_sv3_base_score > 8.9:
            results = "critical"
        return results

    @staticmethod
    def post_vulnerability(vulnerability: "Vulnerability") -> dict:
        """
        Post a vulnerability to the API

        :param Vulnerability vulnerability: The vulnerability to be posted
        :return: The response from the API as a dictionary
        :rtype: dict
        """
        app = Application()
        api = Api(app)
        api_url = urljoin(app.config.get("domain"), "/api/vulnerability")
        payload = vulnerability.model_dump()
        response = api.post(url=api_url, json=payload)
        return response.json() if response.ok else response.raise_for_status()

    @staticmethod
    def post_vulnerabilities(
        app: Application,
        vulnerabilities: List["Vulnerability"],
        output_to_console: Optional[bool] = True,
    ) -> List[Response]:
        """
        Insert new vulnerabilities into RegScale

        :param Application app: Application object
        :param List[Vulnerability] vulnerabilities: List of Vulnerability objects
        :param Optional[bool] output_to_console: Whether to output to console, defaults to True
        :return: A list of Responses
        :rtype List[Response]
        """
        responses = []

        def batch_post(url: str, dat: list[dict]) -> Response:
            """
            Simple wrapper to post a list of JSON data to a URL

            :param str url: URL to post to
            :param list[dict] dat: A list of JSON data to post
            :return: Response object
            :rtype: Response
            """
            res = api.post(url=url, json=dat)
            return res

        api = Api()
        if output_to_console and vulnerabilities:
            api.logger.info("Creating %i new vulnerabilities in RegScale...", len(vulnerabilities))
        # Create batches of vulnerabilities to post
        batch_size = 500
        batches = [vulnerabilities[i : i + batch_size] for i in range(0, len(vulnerabilities), batch_size)]
        for batch in batches:
            res = batch_post(
                url=urljoin(app.config.get("domain"), "/api/vulnerability/batchcreate"),
                dat=[vuln.model_dump() for vuln in batch],
            )
            if res.ok:
                responses.extend(res.json())
        if len(responses):
            api.logger.info("Successfully created %i new vulnerabilities in RegScale", len(responses))
        return responses
