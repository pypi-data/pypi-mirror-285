Index: pyproject.toml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>[build-system]\nbuild-backend = \"hatchling.build\"\nrequires = [\"hatchling\"]\n\n[project]\nname = \"sumo-experiments\"\nversion = \"3.0.0\"\nauthors = [\n    { name=\"Jules Bompard\", email=\"jules.bompard.etu@univ-lille.fr\" },\n    { name=\"Antoine Nongaillard\", email=\"antoine.nongaillard@univ-lille.fr\"},\n    { name=\"Philippe Mathieu\", email=\"philippe.mathieu@univ-lille.fr\"},\n]\ndescription = \"The sumo-experiments library implements a python interface for the Simulation of Urban MObility (SUMO) software.\"\nreadme = \"README.md\"\nrequires-python = \">=3.9\"\nclassifiers = [\n    \"Programming Language :: Python :: 3\",\n    \"License :: OSI Approved :: GNU Lesser General Public License v2 or later (LGPLv2+)\",\n    \"Development Status :: 3 - Alpha\",\n    \"Environment :: X11 Applications :: Gnome\",\n    \"Operating System :: POSIX :: Linux\",\n    \"Topic :: Scientific/Engineering :: Artificial Intelligence\",\n    \"Topic :: Scientific/Engineering :: Interface Engine/Protocol Translator\",\n]\ndependencies = [\n    \"matplotlib >= 3.8.0, < 4\",\n    \"numpy >= 1.26.0, < 2\",\n    \"packaging >= 23.2, < 24\",\n    \"pandas >= 2.1.1, < 3\",\n    \"sumolib >= 1.18.0, < 2\",\n    \"traci >= 1.18.0, < 2\",\n]\n\n[project.urls]\n\"Homepage\" = \"https://github.com/cristal-smac/sumo-experiments\"\n\"Bug Tracker\" = \"https://github.com/cristal-smac/sumo-experiments/issues\"
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pyproject.toml b/pyproject.toml
--- a/pyproject.toml	
+++ b/pyproject.toml	
@@ -4,7 +4,7 @@
 
 [project]
 name = "sumo-experiments"
-version = "3.0.0"
+version = "3.0.1"
 authors = [
     { name="Jules Bompard", email="jules.bompard.etu@univ-lille.fr" },
     { name="Antoine Nongaillard", email="antoine.nongaillard@univ-lille.fr"},
Index: src/sumo_experiments/agents/boolean_agent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from src.sumo_experiments.agents import Agent\nimport traci\n\n\nclass BooleanAgent(Agent):\n    \"\"\"\n    Implements a boolean agent. An intersection managed by this agent must be equipped with boolean detectors, that only\n    detect if a vehicle is on its scope or not. If a detector detects a vehicle for a lane, and not for the lane of other\n    traffic light phases, then the traffic light is set to a phase that is green for this lane. While detectors detect\n    vehicles in lanes where traffic light is green, it remains green until there is no vehicle or the maximum green time\n    of the phase is reached.\n    \"\"\"\n\n    def __init__(self, id_intersection, id_tls_program, intersection_relations, max_phases_durations=None, yellow_time=None):\n        \"\"\"\n        Init of class.\n        :param id_intersection: The id of the intersection the agent will control\n        :type id_intersection: str\n        :param id_tls_program: The id of the traffic light program related to the intersection\n        :type id_tls_program: str\n        :param max_phases_durations: The maximum durations of each traffic light phase (except yellow phases). If None,\n        traffic lights will not switch to another phase until they are car detected on red lanes.\n        :type max_phases_durations: dict\n        :param yellow_time: The duration of yellow phases. If None, yellow phase will remain as declared in the network definition.\n        :type yellow_time: dict\n        :param intersection_relations: The relations for this intersection.\n        :type intersection_relations: dict\n        \"\"\"\n        super().__init__()\n        self.started = False\n        self.id_intersection = id_intersection\n        self.id_tls_program = id_tls_program\n        self.max_phases_durations = max_phases_durations\n        self.yellow_time = yellow_time\n        self.current_phase = 0\n        self.countdown = 0\n        self.relations = intersection_relations\n        self.current_max_time_index = 0\n\n    def choose_action(self):\n        \"\"\"\n        Switch to the next phase when countdown is equal to the current phase duration.\n        :return: True if the agent switched to another phase, False otherwise\n        :rtype: bool\n        \"\"\"\n        if not self.started:\n            self._start_agent()\n            return True\n        red_detectors = self._detectors_red_lanes()\n        green_detectors = self._detectors_green_lanes()\n        if 'y' not in traci.trafficlight.getRedYellowGreenState(self.id_tls_program):\n            red_detection = any([traci.lanearea.getLastStepVehicleNumber(det.id) > 0 for det in red_detectors])\n            if red_detection:\n                green_detection = any([traci.lanearea.getLastStepVehicleNumber(det.id) > 0 for det in green_detectors])\n                if not green_detection:\n                    self.current_phase += 1\n                    traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n                    return True\n            elif self.max_phases_durations is not None:\n                if self.countdown > self.max_phases_durations[self.current_max_time_index % len(self.max_phases_durations)]:\n                    self.current_phase += 1\n                    traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n                    return True\n        else:\n            self.countdown += 1\n        return False\n\n    def _detectors_red_lanes(self):\n        \"\"\"\n        Return the detectors related to red lanes for a phase.\n        :return: The list of all concerned detectors\n        :rtype: list\n        \"\"\"\n        detectors = []\n        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)\n        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)\n        for i in range(len(current_phase)):\n            link = current_phase[i]\n            if link == 'r':\n                link_infos = phases[i]\n                for info in link_infos:\n                    lane = info[0]\n                    lane_number = int(lane.split('_')[-1])\n                    edge = lane[:-2]\n                    edge_index = self.relations['related_edges'].index(edge)\n                    detector = self.relations['related_boolean_detectors'][edge_index][lane_number]\n                    if detector not in detectors:\n                        detectors.append(detector)\n        return detectors\n\n    def _detectors_green_lanes(self):\n        \"\"\"\n        Return the detectors related to green lanes for a phase.\n        :return: The list of all concerned detectors\n        :rtype: list\n        \"\"\"\n        detectors = []\n        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)\n        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)\n        for i in range(len(current_phase)):\n            link = current_phase[i]\n            if link == 'g' or link == 'G':\n                link_infos = phases[i]\n                for info in link_infos:\n                    lane = info[0]\n                    lane_number = int(lane.split('_')[-1])\n                    edge = lane[:-2]\n                    edge_index = self.relations['related_edges'].index(edge)\n                    detector = self.relations['related_boolean_detectors'][edge_index][lane_number]\n                    if detector not in detectors:\n                        detectors.append(detector)\n        return detectors\n\n    def _start_agent(self):\n        \"\"\"\n        Start an agent at the beginning of the simulation.\n        \"\"\"\n        self.nb_phases = len(traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0].phases)\n        tl_logic = traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0]\n        phase_index = 0\n        for phase in tl_logic.phases:\n            if 'y' in phase.state:\n                if self.yellow_time is not None:\n                    phase.duration = self.yellow_time\n                    phase.minDur = self.yellow_time\n                    phase.maxDur = self.yellow_time\n            else:\n                if self.max_phases_durations is not None:\n                    phase.duration = self.max_phases_durations[phase_index] + 5\n                    phase.maxDur = self.max_phases_durations[phase_index] + 5\n                    phase.minDur = self.max_phases_durations[phase_index] + 5\n                else:\n                    phase.duration = 10000\n                    phase.maxDur = 10000\n                    phase.minDur = 10000\n                phase_index += 1\n        traci.trafficlight.setProgramLogic(self.id_tls_program, tl_logic)\n        traci.trafficlight.setPhase(self.id_tls_program, 0)\n        if self.max_phases_durations is not None:\n            traci.trafficlight.setPhaseDuration(self.id_tls_program, self.max_phases_durations[0])\n        else:\n            traci.trafficlight.setPhaseDuration(self.id_tls_program, 10000)\n        self.started = True\n
===================================================================
diff --git a/src/sumo_experiments/agents/boolean_agent.py b/src/sumo_experiments/agents/boolean_agent.py
--- a/src/sumo_experiments/agents/boolean_agent.py	
+++ b/src/sumo_experiments/agents/boolean_agent.py	
@@ -1,4 +1,4 @@
-from src.sumo_experiments.agents import Agent
+from sumo_experiments.agents import Agent
 import traci
 
 
Index: src/sumo_experiments/agents/fixed_time_agent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from src.sumo_experiments.agents import Agent\nimport traci\n\n\nclass FixedTimeAgent(Agent):\n    \"\"\"\n    Implements a fixed time agent. The agent has fixed time for each phase and switch to the next phase when this\n    time is over.\n    \"\"\"\n\n    def __init__(self, id_intersection, id_tls_program, phases_durations):\n        \"\"\"\n        Init of class.\n        :param id_intersection: The id of the intersection the agent will control\n        :type id_intersection: str\n        :param id_tls_program: The id of the traffic light program related to the intersection\n        :type id_tls_program: str\n        :param phases_durations: The durations of each traffic light phase (length = number of phases), including yellows\n        :type phases_durations: iterable object\n        \"\"\"\n        super().__init__()\n        self.started = False\n        self.id_intersection = id_intersection\n        self.phases_durations = phases_durations\n        self.current_phase = 0\n        self.countdown = 0\n        self.nb_phases = len(phases_durations)\n        self.id_tls_program = id_tls_program\n\n    def choose_action(self):\n        \"\"\"\n        Switch to the next phase when countdown is equal to the current phase duration.\n        :return: True if the agent switched to another phase, False otherwise\n        :rtype: bool\n        \"\"\"\n        if not self.started:\n            self._start_agent()\n            return True\n        if self.countdown >= self.phases_durations[self.current_phase % self.nb_phases]:\n            self.current_phase += 1\n            self.countdown = 0\n            traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n            traci.trafficlight.setPhaseDuration(self.id_tls_program, self.phases_durations[self.current_phase % self.nb_phases] + 5)\n            return True\n        else:\n            self.countdown += 1\n            return False\n\n    def _start_agent(self):\n        \"\"\"\n        Start the agent at the beginning of the simulation.\n        \"\"\"\n        traci.trafficlight.setPhase(self.id_tls_program, 0)\n        traci.trafficlight.setPhaseDuration(self.id_tls_program, self.phases_durations[0])\n        self.started = True\n\n
===================================================================
diff --git a/src/sumo_experiments/agents/fixed_time_agent.py b/src/sumo_experiments/agents/fixed_time_agent.py
--- a/src/sumo_experiments/agents/fixed_time_agent.py	
+++ b/src/sumo_experiments/agents/fixed_time_agent.py	
@@ -1,4 +1,4 @@
-from src.sumo_experiments.agents import Agent
+from sumo_experiments.agents import Agent
 import traci
 
 
Index: src/sumo_experiments/agents/numerical_agent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from src.sumo_experiments.agents import Agent\nimport traci\n\n\nclass NumericalAgent(Agent):\n    \"\"\"\n    Implements a numerical agent. An intersection managed by this agent must be equipped with numerical detectors, that\n    count how many vehicles are currently on the watched lane. If a numerical detector counts more vehicle on a red lane\n    than the defined threshold, then it will directly switch to green for this lane. The phases last at least a defined\n    minimum time and at maximum a defined maximum time. It's possible not to define maximum phases time. Then, phases\n    will last until the threshold on other lane is passed.\n    \"\"\"\n\n    def __init__(self,\n                 id_intersection,\n                 id_tls_program,\n                 intersection_relations,\n                 min_phases_durations,\n                 threshold,\n                 counted_vehicles='all',\n                 max_phases_durations=None,\n                 yellow_time=None):\n        \"\"\"\n        Init of class.\n        :param id_intersection: The id of the intersection the agent will control\n        :type id_intersection: str\n        :param id_tls_program: The id of the traffic light program related to the intersection\n        :type id_tls_program: str\n        :param min_phases_durations: The minimum durations of each traffic light phase (except yellow phases). Can't be None.\n        :type min_phases_durations: dict\n        :param threshold: The threshold of vehicles that will release a phase switch\n        :type threshold: int\n        :param counted_vehicles: The vehicles that will be count. 'all' means that all vehicles detected by the numerical\n        detector will be counted. 'stopped' means that only stopped vehicles detected will be counted.\n        :type counted_vehicles: str\n        :param max_phases_durations: The maximum durations of each traffic light phase (except yellow phases). If None,\n        traffic lights will not switch to another phase until they are car detected on red lanes.\n        :type max_phases_durations: dict\n        :param yellow_time: The duration of yellow phases. If None, yellow phase will remain as declared in the network definition.\n        :type yellow_time: dict\n        :param intersection_relations: The relations for this intersection.\n        :type intersection_relations: dict\n        \"\"\"\n        super().__init__()\n        self.started = False\n        self.id_intersection = id_intersection\n        self.id_tls_program = id_tls_program\n        self.min_phases_durations = min_phases_durations\n        self.max_phases_durations = max_phases_durations\n        self.yellow_time = yellow_time\n        self.current_phase = 0\n        self.countdown = 0\n        self.relations = intersection_relations\n        self.current_max_time_index = 0\n        self.threshold = threshold\n        if counted_vehicles == 'all':\n            self.count_function = traci.lanearea.getLastStepVehicleNumber\n        elif counted_vehicles == 'stopped':\n            self.count_function = traci.lanearea.getJamLengthVehicle\n        else:\n            raise ValueError('counted_vehicles argument is not valid.')\n\n    def choose_action(self):\n        \"\"\"\n        If the threshold is passed for a defined lane and the minimum time is exceeded, switch to a phase that is green\n        for this lane.\n        :return: True if the agent switched to another phase, False otherwise\n        :rtype: bool\n        \"\"\"\n        if not self.started:\n            self._start_agent()\n            return True\n        if 'y' not in traci.trafficlight.getRedYellowGreenState(self.id_tls_program):\n            # Check if minimum time is exceeded\n            if self.countdown > self.min_phases_durations[self.phases_index[self.current_phase % self.nb_phases]]:\n                red_detectors = self._detectors_red_lanes()\n                detectors_trigerred = [self.count_function(det.id) >= self.threshold for det in red_detectors]\n                if any(detectors_trigerred):\n                    edges = []\n                    for i in range(len(red_detectors)):\n                        if detectors_trigerred[i]:\n                            edges.append(red_detectors[i].edge)\n                    edges = set(edges)\n                    self.current_phase += 1\n                    traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n                    green_detectors = set(self._detectors_green_lanes())\n                    cpt = 0\n                    while not edges.issubset(green_detectors) and cpt < self.nb_phases:\n                        self.current_phase += 1\n                        traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n                        green_detectors = set(self._detectors_green_lanes())\n                        cpt += 1\n                    if cpt >= self.nb_phases:\n                        self.current_phase += 1\n                        traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)\n                    self.countdown = 0\n                    return True\n            else:\n                self.countdown += 1\n                return False\n\n    def _detectors_red_lanes(self):\n        \"\"\"\n        Return the detectors related to red lanes for a phase.\n        :return: The list of all concerned detectors\n        :rtype: list\n        \"\"\"\n        detectors = []\n        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)\n        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)\n        for i in range(len(current_phase)):\n            link = current_phase[i]\n            if link == 'r':\n                link_infos = phases[i]\n                for info in link_infos:\n                    lane = info[0]\n                    lane_number = int(lane.split('_')[-1])\n                    edge = lane[:-2]\n                    edge_index = self.relations['related_edges'].index(edge)\n                    detector = self.relations['related_numerical_detectors'][edge_index][lane_number]\n                    if detector not in detectors:\n                        detectors.append(detector)\n        return detectors\n\n    def _detectors_green_lanes(self):\n        \"\"\"\n        Return the detectors related to green lanes for a phase.\n        :return: The list of all concerned detectors\n        :rtype: list\n        \"\"\"\n        detectors = []\n        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)\n        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)\n        for i in range(len(current_phase)):\n            link = current_phase[i]\n            if link == 'g' or link == 'G':\n                link_infos = phases[i]\n                for info in link_infos:\n                    lane = info[0]\n                    lane_number = int(lane.split('_')[-1])\n                    edge = lane[:-2]\n                    edge_index = self.relations['related_edges'].index(edge)\n                    detector = self.relations['related_numerical_detectors'][edge_index][lane_number]\n                    if detector not in detectors:\n                        detectors.append(detector)\n        return detectors\n\n    def _start_agent(self):\n        \"\"\"\n        Start an agent at the beginning of the simulation.\n        \"\"\"\n        self.nb_phases = len(traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0].phases)\n        self.phases_index = {}\n        tl_logic = traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0]\n        phase_index = 0\n        nb_phase = 0\n        for phase in tl_logic.phases:\n            if 'y' in phase.state:\n                if self.yellow_time is not None:\n                    phase.duration = self.yellow_time\n                    phase.minDur = self.yellow_time\n                    phase.maxDur = self.yellow_time\n            else:\n                if self.max_phases_durations is not None:\n                    phase.duration = self.max_phases_durations[phase_index] + 5\n                    phase.maxDur = self.max_phases_durations[phase_index] + 5\n                    phase.minDur = self.max_phases_durations[phase_index] + 5\n                else:\n                    phase.duration = 10000\n                    phase.maxDur = 10000\n                    phase.minDur = 10000\n                self.phases_index[nb_phase] = phase_index\n                phase_index += 1\n            nb_phase += 1\n        traci.trafficlight.setProgramLogic(self.id_tls_program, tl_logic)\n        traci.trafficlight.setPhase(self.id_tls_program, 0)\n        if self.max_phases_durations is not None:\n            traci.trafficlight.setPhaseDuration(self.id_tls_program, self.max_phases_durations[0])\n        else:\n            traci.trafficlight.setPhaseDuration(self.id_tls_program, 10000)\n        self.started = True\n
===================================================================
diff --git a/src/sumo_experiments/agents/numerical_agent.py b/src/sumo_experiments/agents/numerical_agent.py
--- a/src/sumo_experiments/agents/numerical_agent.py	
+++ b/src/sumo_experiments/agents/numerical_agent.py	
@@ -1,4 +1,4 @@
-from src.sumo_experiments.agents import Agent
+from sumo_experiments.agents import Agent
 import traci
 
 
