Index: requirements.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>matplotlib==3.8.0\nnumpy==1.26.0\npandas==2.1.1\nsumolib==1.18.0\ntraci==1.18.0\ntensorflow==2.15.0.post1\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/requirements.txt b/requirements.txt
--- a/requirements.txt	(revision 95109e8402233915d1872af43be52d1b373f2fd6)
+++ b/requirements.txt	(date 1715947965747)
@@ -1,6 +1,6 @@
-matplotlib==3.8.0
+matplotlib>=3.8.0
 numpy==1.26.0
-pandas==2.1.1
-sumolib==1.18.0
-traci==1.18.0
+pandas>=2.1.1
+sumolib>=1.18.0
+traci>=1.18.0
 tensorflow==2.15.0.post1
Index: src/sumo_experiments/agents/acolight_agent.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/sumo_experiments/agents/acolight_agent.py b/src/sumo_experiments/agents/acolight_agent.py
new file mode 100644
--- /dev/null	(date 1716277670654)
+++ b/src/sumo_experiments/agents/acolight_agent.py	(date 1716277670654)
@@ -0,0 +1,187 @@
+from sumo_experiments.agents import Agent
+import traci
+
+class AcolightAgent(Agent):
+    """
+    ACoLight agent : Adaptative et COoperative traffic Lights
+    The ACoLight agent works like an actuated controller. The agent has an ordered set of phases, and passes to the
+    next one when a stopping condition is triggered. Each phase has a maximum duration time, increased by delta seconds
+    everytime that no stopping condition has been triggered. Some stopping condition can lower the maximum time by delta
+    seconds when triggered. At the beginning, the maximum duration time is set to the minimum duration time.
+    ACoLight agents can cooperate with each other under certain condition, but the implementation of this behaviour will be
+    done at the strategy level.
+    """
+
+    def __init__(self,
+                 id_intersection,
+                 id_tls_program,
+                 intersection_relations,
+                 min_phases_durations,
+                 delta,
+                 max_phases_durations=None,
+                 yellow_time=None):
+        """
+        Init of class.
+        :param id_intersection: The id of the intersection the agent will control
+        :type id_intersection: str
+        :param id_tls_program: The id of the traffic light program related to the intersection
+        :type id_tls_program: str
+        :param min_phases_durations: The minimum durations of each traffic light phase (except yellow phases). Can't be None.
+        :type min_phases_durations: dict
+        :param delta: The time added or removed from the maximum phase duration when conditions are met.
+        :type delta: int
+        :param max_phases_durations: The maximum durations of each traffic light phase (except yellow phases). If None,
+        phases durations can be increased indefinitely.
+        :type max_phases_durations: dict
+        :param yellow_time: The duration of yellow phases. If None, yellow phase will remain as declared in the network definition.
+        :type yellow_time: dict
+        :param intersection_relations: The relations for this intersection.
+        :type intersection_relations: dict
+        """
+        super().__init__()
+        self.started = False
+        self.id_intersection = id_intersection
+        self.id_tls_program = id_tls_program
+        self.min_phases_durations = min_phases_durations
+        self.max_phases_durations = max_phases_durations
+        self.current_max = min_phases_durations
+        self.yellow_time = yellow_time
+        self.current_phase = 0
+        self.countdown = 0
+        self.relations = intersection_relations
+        self.current_max_time_index = 0
+        self.delta = delta
+
+    def choose_action(self):
+        """
+        If the threshold is passed for a defined lane and the minimum time is exceeded, switch to a phase that is green
+        for this lane.
+        :return: True if the agent switched to another phase, False otherwise
+        :rtype: bool
+        """
+        if not self.started:
+            self._start_agent()
+            return True
+        if 'y' not in traci.trafficlight.getRedYellowGreenState(self.id_tls_program):
+            current_phase_index = self.phases_index[self.current_phase % self.nb_phases]
+            # Check if maximum time is exceeded
+            if self.countdown > self.min_phases_durations[current_phase_index]:
+                if self.countdown < self.current_max[current_phase_index]:
+                    if self._no_vehicles_to_pass():
+                        if self.current_max[current_phase_index] - self.delta >= self.min_phases_durations[current_phase_index]:
+                            self.current_max[current_phase_index] -= self.delta
+                        self.current_phase += 1
+                        traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)
+                        self.countdown = 0
+                        return True
+                    elif self._saturated_red_lane():
+                        self.current_phase += 1
+                        traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)
+                        self.countdown = 0
+                        return True
+                    else:
+                        self.countdown += 1
+                        return False
+                else:
+                    self.current_max[current_phase_index] += self.delta
+                    self.current_phase += 1
+                    traci.trafficlight.setPhase(self.id_tls_program, self.current_phase % self.nb_phases)
+                    self.countdown = 0
+                    return True
+            else:
+                self.countdown += 1
+                return False
+
+    def _no_vehicles_to_pass(self):
+        """
+        Return True if boolean detectors don't detect any vehicles on green lanes.
+        :return: A boolean indicating if there still are vehicles to pass on green lanes.
+        :rtype: bool
+        """
+        green_detectors = self._detectors_green_lanes()
+        green_detection = any([traci.lanearea.getLastStepVehicleNumber(det.id) > 0 for det in green_detectors])
+        return green_detection
+
+    def _saturated_red_lanes(self):
+        """
+        Return True if one of the red lanes is saturated, i.e. the length of the queue has exceeded a maximum value.
+        The detection is made by boolean detectors at the beginning of the road.
+        :return: A boolean indicating if a red lane is saturated
+        :rtype: bool
+        """
+
+    def _detectors_red_lanes(self):
+        """
+        Return the detectors related to red lanes for a phase.
+        :return: The list of all concerned detectors
+        :rtype: list
+        """
+        detectors = []
+        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)
+        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)
+        for i in range(len(current_phase)):
+            link = current_phase[i]
+            if link == 'r':
+                link_infos = phases[i]
+                for info in link_infos:
+                    lane = info[0]
+                    lane_number = int(lane.split('_')[-1])
+                    edge = lane[:-2]
+                    edge_index = self.relations['related_edges'].index(edge)
+                    detector = self.relations['related_boolean_detectors'][edge_index][lane_number]
+                    if detector not in detectors:
+                        detectors.append(detector)
+        return detectors
+
+    def _detectors_green_lanes(self):
+        """
+        Return the detectors related to green lanes for a phase.
+        :return: The list of all concerned detectors
+        :rtype: list
+        """
+        detectors = []
+        current_phase = traci.trafficlight.getRedYellowGreenState(self.id_tls_program)
+        phases = traci.trafficlight.getControlledLinks(self.id_tls_program)
+        for i in range(len(current_phase)):
+            link = current_phase[i]
+            if link == 'g' or link == 'G':
+                link_infos = phases[i]
+                for info in link_infos:
+                    lane = info[0]
+                    lane_number = int(lane.split('_')[-1])
+                    edge = lane[:-2]
+                    edge_index = self.relations['related_edges'].index(edge)
+                    detector = self.relations['related_boolean_detectors'][edge_index][lane_number]
+                    if detector not in detectors:
+                        detectors.append(detector)
+        return detectors
+
+    def _start_agent(self):
+        """
+        Start an agent at the beginning of the simulation.
+        """
+        self.nb_phases = len(traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0].phases)
+        self.phases_index = {}
+        tl_logic = traci.trafficlight.getAllProgramLogics(self.id_tls_program)[0]
+        phase_index = 0
+        nb_phase = 0
+        for phase in tl_logic.phases:
+            if 'y' in phase.state:
+                if self.yellow_time is not None:
+                    phase.duration = self.yellow_time
+                    phase.minDur = self.yellow_time
+                    phase.maxDur = self.yellow_time
+            else:
+                phase.duration = 10000
+                phase.maxDur = 10000
+                phase.minDur = 10000
+                self.phases_index[nb_phase] = phase_index
+                phase_index += 1
+            nb_phase += 1
+        traci.trafficlight.setProgramLogic(self.id_tls_program, tl_logic)
+        traci.trafficlight.setPhase(self.id_tls_program, 0)
+        if self.max_phases_durations is not None:
+            traci.trafficlight.setPhaseDuration(self.id_tls_program, self.max_phases_durations[0])
+        else:
+            traci.trafficlight.setPhaseDuration(self.id_tls_program, 10000)
+        self.started = True
