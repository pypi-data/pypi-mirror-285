"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
Frequenz Reporting API

Copyright:
Copyright 2023 Frequenz Energy-as-a-Service GmbH

License:
MIT
"""

import builtins
import collections.abc
import frequenz.api.common.v1.metrics.metric_sample_pb2
import frequenz.api.common.v1.microgrid.components.components_pb2
import frequenz.api.common.v1.microgrid.microgrid_pb2
import frequenz.api.common.v1.pagination.pagination_info_pb2
import frequenz.api.common.v1.pagination.pagination_params_pb2
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import google.protobuf.timestamp_pb2
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

@typing.final
class TimeFilter(google.protobuf.message.Message):
    """Time-based filter for querying aggregated microgrid components data.

    !!! note
        Specifies the start and end time for the query. Both fields are optional, but
        their absence or presence has specific implications for the query results.
        Data will be returned as a set of rows, which each row containing a timestamp.
        This timestamp will be >= start and < end.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    @property
    def start(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Optional UTC start time for the query.

        !!! info
            If not provided, the query defaults to the earliest available data for the
            specified microgrid components.
        """

    @property
    def end(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """Optional UTC end time for the query.

        !!! info
            If not provided, the query defaults to the most recent available data for the
            specified microgrid components.
        """

    def __init__(
        self,
        *,
        start: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        end: google.protobuf.timestamp_pb2.Timestamp | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["end", b"end", "start", b"start"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["end", b"end", "start", b"start"]) -> None: ...

global___TimeFilter = TimeFilter

@typing.final
class ResamplingOptions(google.protobuf.message.Message):
    """Resampling options for aggregated microgrid components data.
    If data is resampled, all samples that fall in a left-closed time interval
    determined by the resolution will be aggregated.
    At the moment only mean aggregation is supported.
    The timestamp for each aggregated sample represents the beginning of its corresponding
    time interval, marking the earliest point from which data was aggregated.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RESOLUTION_FIELD_NUMBER: builtins.int
    resolution: builtins.int
    """Optional resampling resolution for the data, represented in seconds.
    If omitted, data will be returned in its original resolution.
    """
    def __init__(
        self,
        *,
        resolution: builtins.int | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_resolution", b"_resolution", "resolution", b"resolution"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_resolution", b"_resolution", "resolution", b"resolution"]) -> None: ...
    def WhichOneof(self, oneof_group: typing.Literal["_resolution", b"_resolution"]) -> typing.Literal["resolution"] | None: ...

global___ResamplingOptions = ResamplingOptions

@typing.final
class IncludeOptions(google.protobuf.message.Message):
    """Include options for filtering microgrid components data.

    !!! note
        Specifies which additional fields should be included in the response.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _FilterOption:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _FilterOptionEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[IncludeOptions._FilterOption.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        FILTER_OPTION_UNSPECIFIED: IncludeOptions._FilterOption.ValueType  # 0
        FILTER_OPTION_EXCLUDE: IncludeOptions._FilterOption.ValueType  # 1
        FILTER_OPTION_INCLUDE: IncludeOptions._FilterOption.ValueType  # 2

    class FilterOption(_FilterOption, metaclass=_FilterOptionEnumTypeWrapper):
        """Defines whether to include results in the response message."""

    FILTER_OPTION_UNSPECIFIED: IncludeOptions.FilterOption.ValueType  # 0
    FILTER_OPTION_EXCLUDE: IncludeOptions.FilterOption.ValueType  # 1
    FILTER_OPTION_INCLUDE: IncludeOptions.FilterOption.ValueType  # 2

    BOUNDS_FIELD_NUMBER: builtins.int
    STATES_FIELD_NUMBER: builtins.int
    bounds: global___IncludeOptions.FilterOption.ValueType
    """Optional bound inclusion. By default, bounds are not included in the response."""
    states: global___IncludeOptions.FilterOption.ValueType
    """Optional operational state inclusion. By default, states are not included in the response."""
    def __init__(
        self,
        *,
        bounds: global___IncludeOptions.FilterOption.ValueType | None = ...,
        states: global___IncludeOptions.FilterOption.ValueType | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["_bounds", b"_bounds", "_states", b"_states", "bounds", b"bounds", "states", b"states"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["_bounds", b"_bounds", "_states", b"_states", "bounds", b"bounds", "states", b"states"]) -> None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_bounds", b"_bounds"]) -> typing.Literal["bounds"] | None: ...
    @typing.overload
    def WhichOneof(self, oneof_group: typing.Literal["_states", b"_states"]) -> typing.Literal["states"] | None: ...

global___IncludeOptions = IncludeOptions

@typing.final
class AggregationConfig(google.protobuf.message.Message):
    """Message defining the aggregation configuration for a custom formula within a specific microgrid.

    The AggregationConfig allows clients to specify how metrics should be aggregated across
    microgrid components. It serves as the configuration guideline for any aggregation operation.

    !!! example
       To calculate the total voltage across three components in series with IDs 1, 2, and 3, the
        configuration could look like:
        {
          microgrid_id: 42,
          metric: DC_VOLTAGE_V,
          aggregation_formula: "#1 + #2 + #3"
        }
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    METRIC_FIELD_NUMBER: builtins.int
    AGGREGATION_FORMULA_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """ID of the microgrid for which the formula is being specified."""
    metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType
    """The metric that is to be aggregated using the specified formula.

    !!! caution
        Ensure the chosen metric is supported by all relevant microgrid components.
        Failure to meet these conditions might results in an aggregation error.
    """
    aggregation_formula: builtins.str
    """The formula used for aggregating the component metric for this microgrid.

    !!! info
        Two types of aggregation formulas are supported:
        1. Aggregate functions: These are standard aggregation functions like `sum()` and `avg()`.
           Example: `sum(#1,#2)`, `avg(#3,#4)`

        2. Dedicated formulas: These support basic math operators while concatenating microgrid
           component IDs.
           Example: `#1 + #2 - #3`, `(#3 * #2) /# 1`
    """
    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType = ...,
        aggregation_formula: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["aggregation_formula", b"aggregation_formula", "metric", b"metric", "microgrid_id", b"microgrid_id"]) -> None: ...

global___AggregationConfig = AggregationConfig

@typing.final
class SimpleAggregatedMetricValue(google.protobuf.message.Message):
    """Defines a single aggregated metric sample, which represents a consolidated metric value
    over a collection of microgrid components within a specific timeframe.

    This message serves to encapsulate aggregate metrics derived from multiple component
    measurements. It is particularly useful in scenarios where an overall metric needs to be
    calculated for a set of components. For instance, you could use it to represent the average
    voltage across multiple sources within a microgrid or to calculate the average state of
    charge of several batteries.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAMPLED_AT_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    @property
    def sampled_at(self) -> google.protobuf.timestamp_pb2.Timestamp:
        """The UTC sample timestamp for the aggregated metrics.

        !!! info
            This is the original timestamp of the samples that were aggregated.
        """

    @property
    def sample(self) -> frequenz.api.common.v1.metrics.metric_sample_pb2.SimpleMetricValue:
        """The aggregated value of the metric.
        float value = 2;
        """

    def __init__(
        self,
        *,
        sampled_at: google.protobuf.timestamp_pb2.Timestamp | None = ...,
        sample: frequenz.api.common.v1.metrics.metric_sample_pb2.SimpleMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["sample", b"sample", "sampled_at", b"sampled_at"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["sample", b"sample", "sampled_at", b"sampled_at"]) -> None: ...

global___SimpleAggregatedMetricValue = SimpleAggregatedMetricValue

@typing.final
class MetricSourceOptions(google.protobuf.message.Message):
    """Filter for sources for metrics, specified for a single metric at a time.
    Specifying a metric here will only stream data for that metric where data
    can be found tagged with the given source names.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    METRIC_FIELD_NUMBER: builtins.int
    METRIC_SOURCES_FIELD_NUMBER: builtins.int
    metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType
    """The metric for which sources will be filtered."""
    @property
    def metric_sources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """A list of sources to allow for the specified metric.
        If this list is empty, then no data for this metric is streamed.
        """

    def __init__(
        self,
        *,
        metric: frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType = ...,
        metric_sources: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["metric", b"metric", "metric_sources", b"metric_sources"]) -> None: ...

global___MetricSourceOptions = MetricSourceOptions

@typing.final
class ListMicrogridComponentsDataRequest(google.protobuf.message.Message):
    """Message defining the request format for fetching historical metrics, such as electrical
    measurements, and other information for individual microgrid components.

    !!! note
        In addition to the raw metrics, the API can also return additional information
        like errors or operational states of the components during the specified time period.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class ListFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid components data."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        INCLUDE_OPTIONS_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria."""

        @property
        def include_options(self) -> global___IncludeOptions:
            """Include options specifying additional fields to be included in the response."""

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
            include_options: global___IncludeOptions | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    MICROGRID_COMPONENTS_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    PAGINATION_PARAMS_FIELD_NUMBER: builtins.int
    @property
    def microgrid_components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs]:
        """Encapsulates the microgrid ID and the component IDs within that microgrid for which
        the historical data should be retrieved.

        !!! note
            Each entry in this repeated field associates a microgrid ID with its respective
            component IDs. At least one such association must be provided for a valid request.
        """

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType]:
        """List of metrics to return. Only the specified metrics will be returned.

        !!! note
            At least one metric must be specified. Failure to do so will result in an empty response.
        """

    @property
    def filter(self) -> global___ListMicrogridComponentsDataRequest.ListFilter:
        """General filter criteria apply to the data retrieval for all specified microgrid components.

        !!! note
            The filter can specify a start time and end time, and/or resampling options.
            It can also specify bounds, operational state, or errors to be returned.
        """

    @property
    def pagination_params(self) -> frequenz.api.common.v1.pagination.pagination_params_pb2.PaginationParams:
        """Pagination parameters to control the amount of data returned in a single response."""

    def __init__(
        self,
        *,
        microgrid_components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs] | None = ...,
        metrics: collections.abc.Iterable[frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType] | None = ...,
        filter: global___ListMicrogridComponentsDataRequest.ListFilter | None = ...,
        pagination_params: frequenz.api.common.v1.pagination.pagination_params_pb2.PaginationParams | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter", "pagination_params", b"pagination_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "metrics", b"metrics", "microgrid_components", b"microgrid_components", "pagination_params", b"pagination_params"]) -> None: ...

global___ListMicrogridComponentsDataRequest = ListMicrogridComponentsDataRequest

@typing.final
class ListMicrogridComponentsDataResponse(google.protobuf.message.Message):
    """Response containing historical microgrid component metrics in one or multiple microgrids

    Each microgrid's components are provided as timeseries data structures that encapsulate
    metrics, bounds, errors and operational state and their associated timestamps for each component
    within the specified time range.

    !!! example
        Example output structure:
        ```
        microgrids: [
          {
            microgrid_id: 1,
            components: [
              {
                component_id: 13,
                metric_samples: [
                  /* list of metrics for multiple timestamps */
                  { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                  { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
                  { sampled_at: "2023-10-01T00:05:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                  { sampled_at: "2023-10-01T00:05:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
                ],
                states: [
                  /* list of states for multiple timestamps */
                  { sampled_at: "2023-10-01T00:00:13.12Z", states: [...], errors: [...], warnings: [...] },
                  { sampled_at: "2023-10-01T00:02:22.01Z", states: [...], errors: [...], warnings: [...] },
                  { sampled_at: "2023-10-01T00:05:02.32Z", states: [...], errors: [...], warnings: [...] },
                ]
              },
              {
                component_id: 243,
                metric_samples: [ ... ],
                states: [ ... ]
              },
            ]
          },
          {
            microgrid_id: 2,
            components: [ ... ]
          }
        ]
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class MicrogridData(google.protobuf.message.Message):
        """Contains the metric samples for a single microgrid organized by components."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        MICROGRID_ID_FIELD_NUMBER: builtins.int
        COMPONENTS_FIELD_NUMBER: builtins.int
        microgrid_id: builtins.int
        """Unique microgrid identifier."""
        @property
        def components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData]:
            """A list of components with related metric timeseries data samples."""

        def __init__(
            self,
            *,
            microgrid_id: builtins.int = ...,
            components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData] | None = ...,
        ) -> None: ...
        def ClearField(self, field_name: typing.Literal["components", b"components", "microgrid_id", b"microgrid_id"]) -> None: ...

    MICROGRIDS_FIELD_NUMBER: builtins.int
    PAGINATION_INFO_FIELD_NUMBER: builtins.int
    @property
    def microgrids(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ListMicrogridComponentsDataResponse.MicrogridData]:
        """List of microgrids metrics timeseries data, organized per component."""

    @property
    def pagination_info(self) -> frequenz.api.common.v1.pagination.pagination_info_pb2.PaginationInfo:
        """Metadata for pagination, including token for the next page to retrieve."""

    def __init__(
        self,
        *,
        microgrids: collections.abc.Iterable[global___ListMicrogridComponentsDataResponse.MicrogridData] | None = ...,
        pagination_info: frequenz.api.common.v1.pagination.pagination_info_pb2.PaginationInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["pagination_info", b"pagination_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["microgrids", b"microgrids", "pagination_info", b"pagination_info"]) -> None: ...

global___ListMicrogridComponentsDataResponse = ListMicrogridComponentsDataResponse

@typing.final
class ReceiveMicrogridComponentsDataStreamRequest(google.protobuf.message.Message):
    """Request message for receiving stream of metrics, such as electrical
    measurements, and other information for individual microgrid components.

    !!! note
        In addition to the raw metrics, the API can also return additional information
        like errors or operational states of the components during the specified time period.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class StreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid components data.

        !!! note
            The filter criteria defined here are applied universally across all
            specified microgrids and their respective components.
        """

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        INCLUDE_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        METRIC_SOURCES_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def include_options(self) -> global___IncludeOptions:
            """Include options specifying additional fields to be included in the response."""

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        @property
        def metric_sources(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MetricSourceOptions]:
            """List of metric source filters
            For the metrics present in this list, the data from only the specified
            sources will be returned. If no sources are provided for a metric in this
            list, then no data will be returned for the said metric.
            For the metrics not present in this list, data from all of their sources will
            be returned.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            include_options: global___IncludeOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
            metric_sources: collections.abc.Iterable[global___MetricSourceOptions] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["include_options", b"include_options", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["include_options", b"include_options", "metric_sources", b"metric_sources", "resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    MICROGRID_COMPONENTS_FIELD_NUMBER: builtins.int
    METRICS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def microgrid_components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs]:
        """Encapsulates the microgrid ID and the component IDs within that microgrid for which
        the historical data should be retrieved.

        !!! note
            Each entry in this repeated field associates a microgrid ID with its respective
            component IDs. At least one such association must be provided for a valid request.
        """

    @property
    def metrics(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType]:
        """List of metrics to return. Only the specified metrics will be returned.

        !!! note
            At least one metric must be specified. Failure to do so will result in an empty response.
        """

    @property
    def filter(self) -> global___ReceiveMicrogridComponentsDataStreamRequest.StreamFilter:
        """General filter that applies to the data retrieval for all specified microgrids and components.

        !!! note
            The filter can specify a list of metrics to be return but also specify bounds, operational
            state, or errors to be returned.
        """

    def __init__(
        self,
        *,
        microgrid_components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.microgrid_pb2.MicrogridComponentIDs] | None = ...,
        metrics: collections.abc.Iterable[frequenz.api.common.v1.metrics.metric_sample_pb2.Metric.ValueType] | None = ...,
        filter: global___ReceiveMicrogridComponentsDataStreamRequest.StreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["filter", b"filter", "metrics", b"metrics", "microgrid_components", b"microgrid_components"]) -> None: ...

global___ReceiveMicrogridComponentsDataStreamRequest = ReceiveMicrogridComponentsDataStreamRequest

@typing.final
class ReceiveMicrogridComponentsDataStreamResponse(google.protobuf.message.Message):
    """Response containing a single data sample for one microgrid's components.

    !!! note
        The microgrid's components are provided as single data samples that
        encapsulate metrics, bounds, errors, and operational states along with their
        associated timestamps. Each response message covers a single microgrid.
        If multiple microgrids are provided in the request, expect sequential messages
        in the stream.

    !!! example
        Example output structure:
        ```
        {
          microgrid_id: 1,
          components: [
            {
              component_id: 13,
              metric_samples: [
                /* all metrics belong to the same timestamp */
                /* sample is type MetricSampleVariant */
                { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
              ],
              state: {
                sampled_at: "2023-10-01T00:00:13.12Z",
                states: ["COMPONENT_STATE_CHARGING", "CABLE_CONNECTED"],
                warnings: []
                errors: [],
              ]
            },
            {
              component_id: 59,
              metric_samples: [
                /* all metrics belong to the same timestamp */
                /* sample is type MetricSampleVariant */
                { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_VOLTAGE_V", sample: {...}, bounds: {...} },
                { sampled_at: "2023-10-01T00:00:00Z", metric: "DC_CURRENT_A", sample: {...}, bounds: {...} }
              ],
              state: {
                sampled_at: "2023-10-01T00:00:13.12Z",
                states: ["COMPONENT_STATE_ERROR"],
                warnings: []
                errors: ["COMPONENT_ERROR_CODE_BATTERY_RELAY_ERROR"],
              ]
            }
          ]
        }
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MICROGRID_ID_FIELD_NUMBER: builtins.int
    COMPONENTS_FIELD_NUMBER: builtins.int
    microgrid_id: builtins.int
    """Microgrid ID for which the components and samples are reported."""
    @property
    def components(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData]:
        """List of components within this microgrid, each with its associated data samples."""

    def __init__(
        self,
        *,
        microgrid_id: builtins.int = ...,
        components: collections.abc.Iterable[frequenz.api.common.v1.microgrid.components.components_pb2.ComponentData] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["components", b"components", "microgrid_id", b"microgrid_id"]) -> None: ...

global___ReceiveMicrogridComponentsDataStreamResponse = ReceiveMicrogridComponentsDataStreamResponse

@typing.final
class ListAggregatedMicrogridComponentsDataRequest(google.protobuf.message.Message):
    """Message defining the request format for fetching aggregated historical metrics
    for a list of microgrid components. This request allows to specify custom
    aggregation formulas, along with general filtering and pagination options.

    !!! note
            The aggregation follows the passive sign convention. Bounds, operational
            state, or errors are not applicable to aggregated data.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggregationListFilter(google.protobuf.message.Message):
        """General filter criteria for querying aggregated microgrid components data."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            Data will always be resampled to ensure consistency of the aggregation.
            If omitted, data will be resampled with a default of one second
            """

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria."""

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    AGGREGATION_CONFIGS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    PAGINATION_PARAMS_FIELD_NUMBER: builtins.int
    @property
    def aggregation_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationConfig]:
        """List of aggregation formulas, composed of a metric and related formula.

        !!! note
            Each entry in the list consists of a pairs a metric and aggregation formula. Multiple such
            aggregations can be specified for a list of microgrid components, allowing for different
            metrics and formula combinations. At least one formula must be provided for a valid
            request.
        """

    @property
    def filter(self) -> global___ListAggregatedMicrogridComponentsDataRequest.AggregationListFilter:
        """General filter that applies to all formula aggregations provided."""

    @property
    def pagination_params(self) -> frequenz.api.common.v1.pagination.pagination_params_pb2.PaginationParams:
        """Pagination parameters to control the amount of data returned in a single response."""

    def __init__(
        self,
        *,
        aggregation_configs: collections.abc.Iterable[global___AggregationConfig] | None = ...,
        filter: global___ListAggregatedMicrogridComponentsDataRequest.AggregationListFilter | None = ...,
        pagination_params: frequenz.api.common.v1.pagination.pagination_params_pb2.PaginationParams | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter", "pagination_params", b"pagination_params"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_configs", b"aggregation_configs", "filter", b"filter", "pagination_params", b"pagination_params"]) -> None: ...

global___ListAggregatedMicrogridComponentsDataRequest = ListAggregatedMicrogridComponentsDataRequest

@typing.final
class ListAggregatedMicrogridComponentsDataResponse(google.protobuf.message.Message):
    """Message defining the response format for a request that fetches aggregated historical
    metrics based on custom aggregation formulas.

    !!! note
        At least one formula and metric must have been specified in the corresponding request.
        The aggregation results for these metrics are returned in the samples field.

    !!! example
        Example output structure is the following:
        ```
        results: [
          {
            aggregation_config: {
              microgrid_id: 1,
              metric: "DC_VOLTAGE_V",
              aggregation_formula: "avg(3,5,6)"
            },
            samples: [
              { sampled_at: "2023-10-01T00:00:00Z", sample: { value: 220.1 } },
              { sampled_at: "2023-10-01T00:05:00Z", sample: { value: 215.2 } }
            ]
          },
          {
            aggregation_config: {
              microgrid_id: 2,
              metric: "DC_CURRENT_A",
              aggregation_formula: "sum(1,2,3,4)"
            },
            samples: [
              { sampled_at: "2023-10-01T00:00:00Z", sample: { value: 1310.7 } },
              { sampled_at: "2023-10-01T00:05:00Z", sample: { value: 1422.2 } }
            ]
          }
        ]
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggregatedResult(google.protobuf.message.Message):
        """Encapsulates the result of aggregating a metric."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        AGGREGATION_CONFIG_FIELD_NUMBER: builtins.int
        SAMPLES_FIELD_NUMBER: builtins.int
        @property
        def aggregation_config(self) -> global___AggregationConfig:
            """Metric and related formula provided for aggregation."""

        @property
        def samples(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SimpleAggregatedMetricValue]:
            """A list of aggregated metrics."""

        def __init__(
            self,
            *,
            aggregation_config: global___AggregationConfig | None = ...,
            samples: collections.abc.Iterable[global___SimpleAggregatedMetricValue] | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "samples", b"samples"]) -> None: ...

    RESULTS_FIELD_NUMBER: builtins.int
    PAGINATION_INFO_FIELD_NUMBER: builtins.int
    @property
    def results(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___ListAggregatedMicrogridComponentsDataResponse.AggregatedResult]:
        """List of aggregated results, each corresponding to a metric and custom aggregation
        formula.

        !!! note
            Each entry in this list contains the aggregation formula config and the
            corresponding aggregated metric samples for the requested timeframe.
        """

    @property
    def pagination_info(self) -> frequenz.api.common.v1.pagination.pagination_info_pb2.PaginationInfo:
        """Metadata for pagination, containing the token for the next page of results.

        !!! note
            If `pagination_info` is populated, it implies that more data is available to fetch.
        """

    def __init__(
        self,
        *,
        results: collections.abc.Iterable[global___ListAggregatedMicrogridComponentsDataResponse.AggregatedResult] | None = ...,
        pagination_info: frequenz.api.common.v1.pagination.pagination_info_pb2.PaginationInfo | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["pagination_info", b"pagination_info"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["pagination_info", b"pagination_info", "results", b"results"]) -> None: ...

global___ListAggregatedMicrogridComponentsDataResponse = ListAggregatedMicrogridComponentsDataResponse

@typing.final
class ReceiveAggregatedMicrogridComponentsDataStreamRequest(google.protobuf.message.Message):
    """Message defining the request format for streaming aggregated historical metrics.
    This request allows to specify custom aggregation formulas, along with general
    filtering.

    At least one aggregation formula config must be provided. The aggregation
    follows the passive sign convention.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class AggregationStreamFilter(google.protobuf.message.Message):
        """General filter criteria for querying microgrid components data."""

        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        RESAMPLING_OPTIONS_FIELD_NUMBER: builtins.int
        TIME_FILTER_FIELD_NUMBER: builtins.int
        @property
        def resampling_options(self) -> global___ResamplingOptions:
            """Optional resampling options like resolution for the data, represented in seconds.
            If omitted, data will be returned in its original representation.
            """

        @property
        def time_filter(self) -> global___TimeFilter:
            """Optional time-based filter criteria.
            If omitted, data will start streaming from the timestamp that the request was received.
            """

        def __init__(
            self,
            *,
            resampling_options: global___ResamplingOptions | None = ...,
            time_filter: global___TimeFilter | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["resampling_options", b"resampling_options", "time_filter", b"time_filter"]) -> None: ...

    AGGREGATION_CONFIGS_FIELD_NUMBER: builtins.int
    FILTER_FIELD_NUMBER: builtins.int
    @property
    def aggregation_configs(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___AggregationConfig]:
        """List of pairs of metric and corresponding aggregation formula."""

    @property
    def filter(self) -> global___ReceiveAggregatedMicrogridComponentsDataStreamRequest.AggregationStreamFilter:
        """General streaming filter that applies to all formula aggregations."""

    def __init__(
        self,
        *,
        aggregation_configs: collections.abc.Iterable[global___AggregationConfig] | None = ...,
        filter: global___ReceiveAggregatedMicrogridComponentsDataStreamRequest.AggregationStreamFilter | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["filter", b"filter"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_configs", b"aggregation_configs", "filter", b"filter"]) -> None: ...

global___ReceiveAggregatedMicrogridComponentsDataStreamRequest = ReceiveAggregatedMicrogridComponentsDataStreamRequest

@typing.final
class ReceiveAggregatedMicrogridComponentsDataStreamResponse(google.protobuf.message.Message):
    """Message defining the response format for a stream that fetches aggregated real-time metrics
    for the provided custom aggregation formulas.

    !!! note
        The formula and metric must have been specified in the corresponding request.
        A single aggregated sample for the metric is returned in the sample field. Each message
        covers a single formula. For multiple formulars provided in the request, expect sequential
        messages in the stream.

    !!! example
        Given a stream output, a single sample might be:
        ```
        {
          aggregation_config: {
            microgrid_id: 1,
            metric: "DC_VOLTAGE_V",
            aggregation_formula: "avg(1,2,3)"
          },
          sample {
            sampled_at: '2023-10-01T00:00:00Z',
            sample: { value: 42.5 }
          }
        }
        ```
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    AGGREGATION_CONFIG_FIELD_NUMBER: builtins.int
    SAMPLE_FIELD_NUMBER: builtins.int
    @property
    def aggregation_config(self) -> global___AggregationConfig:
        """The metric and formula that has been used to aggregate the sample."""

    @property
    def sample(self) -> global___SimpleAggregatedMetricValue:
        """Aggregated sample value and corresponding UTC timestamp when it was sampled."""

    def __init__(
        self,
        *,
        aggregation_config: global___AggregationConfig | None = ...,
        sample: global___SimpleAggregatedMetricValue | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["aggregation_config", b"aggregation_config", "sample", b"sample"]) -> None: ...

global___ReceiveAggregatedMicrogridComponentsDataStreamResponse = ReceiveAggregatedMicrogridComponentsDataStreamResponse
