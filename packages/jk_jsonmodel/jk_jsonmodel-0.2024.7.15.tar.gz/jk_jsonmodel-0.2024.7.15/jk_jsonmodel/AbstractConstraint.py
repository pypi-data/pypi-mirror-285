


import typing




class AbstractConstraint(object):

	################################################################################################################################
	## Constructor
	################################################################################################################################

	################################################################################################################################
	## Public Properties
	################################################################################################################################

	################################################################################################################################
	## Helper Methods
	################################################################################################################################

	################################################################################################################################
	## Public Methods
	################################################################################################################################

	def __call__(self, value) -> typing.Union[str,None]:
		raise NotImplementedError()
	#

#




class _ConstraintSequence(AbstractConstraint):

	################################################################################################################################
	## Constructor
	################################################################################################################################

	def __init__(self, sequence:typing.List[AbstractConstraint]) -> None:
		self.__sequence = sequence
	#

	################################################################################################################################
	## Public Properties
	################################################################################################################################

	################################################################################################################################
	## Helper Methods
	################################################################################################################################

	################################################################################################################################
	## Public Methods
	################################################################################################################################

	def __call__(self, value) -> typing.Union[str,None]:
		for c in self.__sequence:
			s = c(value)
			if s:
				return s
		return None
	#

#



def _packConstraints(constraints:typing.Tuple[AbstractConstraint]) -> typing.Union[AbstractConstraint,None]:
	assert isinstance(constraints, tuple)

	if len(constraints) == 0:
		return None

	if len(constraints) == 1:
		if not isinstance(constraints[0], AbstractConstraint):
			raise Exception("Not a constraint: " + str(constraints[0]))
		return constraints[0]

	ret = []
	for i, c in enumerate(constraints):
		if not isinstance(c, AbstractConstraint):
			raise Exception("Not a constraint at index {}: {}".format(i, str(c)))
		ret.append(c)
	return _ConstraintSequence(ret)
#


