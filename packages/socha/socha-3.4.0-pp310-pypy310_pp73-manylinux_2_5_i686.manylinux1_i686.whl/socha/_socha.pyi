from enum import Enum
from typing import List, Optional

class Card(Enum):
    FallBack: int = 0
    HurryAhead: int = 1
    EatSalad: int = 2
    SwapCarrots: int = 3

    def __init__(self) -> None: ...
    def moves(self) -> bool: ...
    def perform(self, state: GameState) -> None: ...

class Advance:
    distance: int
    cards: List[Card]

    def __init__(self, distance: int, cards: List[Card]): ...
    def perform(self, state: GameState) -> None: ...

class EatSalad:
    def __init__(self) -> None: ...
    def perform(self, state: GameState) -> None: ...

class ExchangeCarrots:
    amount: int

    def __init__(self, amount: int) -> None: ...
    def perform(self, state: GameState) -> None: ...

class FallBack:
    def __init__(self) -> None: ...
    def perform(self, state: GameState) -> None: ...

class Field(Enum):
    Position1: int = 0
    Position2: int = 1
    Hedgehog: int = 2
    Salad: int = 3
    Carrots: int = 4
    Hare: int = 5
    Market: int = 6
    Goal: int = 7
    Start: int = 8

class Board:
    track: list[Field]

    def __init__(self, track: list[Field]) -> None: ...
    def get_field(self, index: int) -> Optional[Field]: ...
    def find_field(self, field: Field, start: int, end: int) -> Optional[int]: ...
    def get_previous_field(self, field: Field, index: int) -> Optional[int]: ...
    def get_next_field(self, field: Field, index: int) -> Optional[int]: ...

class TeamEnum(Enum):
    One: int = 0
    Two: int = 1

    def __repr__(self) -> str: ...

class Hare:
    team: TeamEnum
    position: int
    salads: int
    carrots: int
    last_move: Optional[Move]
    cards: List[Card]

    def __init__(
        self,
        team: TeamEnum,
        cards: Optional[List[Card]] = None,
        carrots: Optional[int] = None,
        salads: Optional[int] = None,
        last_move: Optional[Move] = None,
        position: Optional[int] = None,
    ) -> None: ...
    def is_in_goal(self) -> bool: ...
    def can_enter_goal(self) -> bool: ...
    def advance_by(self, state: GameState, distance: int) -> None: ...
    def exchange_carrots(self, state: GameState, carrots: int) -> None: ...
    def consume_carrots(self, state: GameState, carrots: int) -> None: ...
    def eat_salad(self, state: GameState) -> None: ...
    def move_to_field(self, state: GameState, new_position: int) -> None: ...
    def get_fall_back(self, state: GameState) -> Optional[int]: ...
    def fall_back(self, state: GameState) -> None: ...
    def is_ahead(self, state: GameState) -> bool: ...

class Move:
    action: Advance | EatSalad | ExchangeCarrots | FallBack

    def __init__(
        self, action: Advance | EatSalad | ExchangeCarrots | FallBack
    ) -> None: ...
    def perform(self, state: GameState) -> None: ...
    def __repr__(self) -> str: ...

class GameState:
    board: Board
    turn: int

    def __init__(
        self, board: Board, turn: int, player_one: Hare, player_two: Hare
    ) -> None: ...
    def perform_move(self, move: Move) -> GameState: ...
    def clone_current_player(self) -> Hare: ...
    def clone_other_player(self) -> Hare: ...
    def update_player(self, player: Hare) -> None: ...
    def is_over(self) -> bool: ...
    def possible_moves(self) -> List[Move]: ...

class RulesEngine:
    @staticmethod
    def calculates_carrots(distance: int) -> int: ...
    @staticmethod
    def can_exchange_carrots(board: Board, player: Hare, count: int) -> None: ...
    @staticmethod
    def can_eat_salad(board: Board, player: Hare) -> None: ...
    @staticmethod
    def has_to_eat_salad(board: Board, player: Hare) -> None: ...
    @staticmethod
    def can_advance_to(
        board: Board, new_position: int, player: Hare, other_player: Hare
    ) -> None: ...

class PluginConstants:
    NUM_FIELDS: int
    INITIAL_SALADS: int
    INITIAL_CARROTS: int
    ROUND_LIMIT: int
