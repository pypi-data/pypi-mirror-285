Index: anaTHz/process/process_data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/anaTHz/process/process_data.py b/parrot/process/process_data.py
rename from anaTHz/process/process_data.py
rename to parrot/process/process_data.py
--- a/anaTHz/process/process_data.py	
+++ b/parrot/process/process_data.py	
@@ -10,7 +10,7 @@
         self.recording_type = recording_type
         pass
 
-    def dark_and_thz(self, light, dark, **kwargs):
+    def thz_and_dark(self, light, dark, **kwargs):
         raw_data = {}
         for mode, data in zip(["light", "dark"], [light, dark]):
             raw_data[mode] = {"time": data["time"],
@@ -18,12 +18,41 @@
                               "signal": data["signal"]}
         data = {"light": PrepareData(raw_data["light"], self.recording_type, **kwargs).run(),
                 "dark": {}}
-        data["dark"] = PrepareData(raw_data["dark"],
-                                   delay_value=data["light"]["delay_value"],
-                                   **kwargs).run()
+        if 'delay_value' in kwargs:
+            data["dark"] = PrepareData(raw_data["dark"],
+                                       **kwargs).run()
+        else:
+            data["dark"] = PrepareData(raw_data["dark"],
+                                       delay_value=data["light"]["delay_value"],
+                                       **kwargs).run()
         for mode in ["light", "dark"]:
             data[mode] = CutData(data[mode]).run()
         return data
+
+    def thz_and_two_darks(self, light, dark1, dark2, **kwargs):
+        raw_data = {}
+        for mode, data in zip(["light", "dark1", "dark2"], [light, dark1, dark2]):
+            raw_data[mode] = {"time": data["time"],
+                              "position": data["position"],
+                              "signal": data["signal"]}
+        data = {"light": PrepareData(raw_data["light"], self.recording_type, **kwargs).run(),
+                "dark1": {},
+                "dark2": {}}
+        if 'delay_value' in kwargs:
+            data["dark1"] = PrepareData(raw_data["dark1"],
+                                       **kwargs).run()
+            data["dark2"] = PrepareData(raw_data["dark2"],
+                                       **kwargs).run()
+        else:
+            data["dark1"] = PrepareData(raw_data["dark1"],
+                                       delay_value=data["light"]["delay_value"],
+                                       **kwargs).run()
+            data["dark2"] = PrepareData(raw_data["dark2"],
+                                       delay_value=data["light"]["delay_value"],
+                                       **kwargs).run()
+        for mode in ["light", "dark1", "dark2"]:
+            data[mode] = CutData(data[mode]).run()
+        return data
 
     def thz_only(self, light, **kwargs):
         raw_data = {"light": {"time": light["time"],
Index: anaTHz/process/prepare_data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/anaTHz/process/prepare_data.py b/parrot/process/prepare_data.py
rename from anaTHz/process/prepare_data.py
rename to parrot/process/prepare_data.py
--- a/anaTHz/process/prepare_data.py	
+++ b/parrot/process/prepare_data.py	
@@ -1,6 +1,7 @@
 import numpy as np
 from scipy.signal import sosfiltfilt, butter, find_peaks, correlate, correlation_lags
 from scipy.optimize import minimize
+import scipy.interpolate as interp
 # TODO: Remove matplotlib later (but not EngFormatter)
 import matplotlib
 
@@ -25,6 +26,7 @@
                  filter_signal=True,
                  lowcut_signal=1,
                  highcut_signal=None,
+                 consider_all_traces=False,
                  debug=False):
         # scale:        Scale between [V] of position data and light time [s]
         #               For example for the APE 50 ps shaker it would be scale=50e-12/20 (50 ps for +-10V)
@@ -51,6 +53,9 @@
         self.data["number_of_traces"] = None
         self.data["interpolation_resolution"] = None
         self.data["trace_cut_index"] = None
+        # Consider, if all traces are used to calculate standard deviation (STD) to find optimal delay.
+        # This can speed up finding the optimal delay, this setting is capping number of traces to 100 to evaluate STD.
+        self.consider_all_traces = consider_all_traces
 
     def run(self):
         if self.filter_position:
@@ -118,6 +123,11 @@
                 ax[0].xaxis.set_major_formatter(EngFormatter(unit='s'))
                 ax[0].yaxis.set_major_formatter(EngFormatter(unit='V'))
                 ax[0].set_title('Signal vs. Delay without time delay compensation')
+            self.original_time = np.arange(0, self.dt * len(self.data["position"]), self.dt)
+            self.position_interpolated = interp.interp1d(self.original_time,
+                                                         self.data["position"],
+                                                         bounds_error=False,
+                                                         fill_value=np.nan)
             if self.data["delay_value"] is None:
                 self.data["delay_value"] = self.get_delay()
             self.shift_position(self.data["delay_value"])
@@ -149,15 +159,19 @@
         The max. slope of the position data vs. lab time is the smallest max. THz frequency
         """
         # TODO: Needs to be checked
+        # TODO: Currently just skipping values by a factor, we can improve the signal to
+        #  first low-pass filter it, then take the larger steps
         max_native_frequency = 1 / (np.max(np.gradient(self.data["position"], self.dt)) * self.data[
             "scale"] * self.dt)  # [V/s] * [ps/V] --> scaling factor
         factor = np.int64(np.floor(max_native_frequency / self.max_THz_frequency))
+        if factor < 1:
+            factor = 1
         current_time = np.arange(0, len(self.data["position"]) * self.dt, self.dt)
         new_dt = factor * self.dt
         new_time = np.arange(0, len(self.data["position"]) * self.dt, new_dt)
         if self.debug:
             print(
-                f"INFO: Current time sample: {self.dt}s per sample. New time sample: {new_dt}s per sample.")
+                f"INFO: Current time sample: {EngFormatter('s')(self.dt)} per sample. New time sample: {EngFormatter('s')(new_dt)} per sample.")
         self.data["position"] = np.interp(new_time, current_time, self.data["position"])
         self.data["signal"] = np.interp(new_time, current_time, self.data["signal"])
         self.dt = new_dt
@@ -195,67 +209,56 @@
         self.data["number_of_traces"] = len(self.data["trace_cut_index"]) + 1
 
     def get_delay(self):
+        self.orig_signal_norm = (self.data["signal"] - np.min(self.data["signal"])) / (
+                    np.max(self.data["signal"]) - np.min(self.data["signal"]))
+        self.interpolated_delay = np.linspace(0, 1, self.data["interpolation_resolution"])
         x0 = [0]
         init_simplex = np.array([0, 10]).reshape(2, 1)
-        xatol = 0.5
-        fatol = 0.5
-        if self.debug:
-            print("INFO: Optimizing delay between position and signal array to align forward and backward THz traces.")
-        res = minimize(self.minimize_delay,
+        xatol = 0.1
+        res = minimize(self._minimize,
                        x0,
                        method="Nelder-Mead",
-                       options={"disp": False,
+                       options={"disp": True,
                                 "maxiter": 30,
-                                "fatol": fatol,
                                 "xatol": xatol,
                                 "initial_simplex": init_simplex})
-        if self.debug:
-            print(f"INFO: A delay of {int(np.round(res.x[0]))} minimizes the error "
-                  "and aligns forward and backward traces.")
-        return int(np.round(res.x[0]))
+        return res.x[0]
 
-    def minimize_delay(self, delay):
-        delay = int(np.round(delay))
-        pos = np.copy(self.data["position"])
-        sig = np.copy(self.data["signal"])
-        if delay < 0:
-            sig = np.roll(sig, delay)
-            pos[delay:] = np.nan
-            sig[delay:] = np.nan
-        else:
-            sig = np.roll(sig, delay)
-            pos[:delay] = np.nan
-            sig[:delay] = np.nan
-        pos = pos[~np.isnan(pos)]
-        sig = sig[~np.isnan(sig)]
-        pos_list = np.split(pos, self.data["trace_cut_index"])
-        sig_list = np.split(sig, self.data["trace_cut_index"])
+    def _minimize(self, delay):
+        new_time_axis = delay * self.dt + np.copy(self.original_time)
+        new_position = self.position_interpolated(new_time_axis)
+        new_position = (new_position - np.nanmin(new_position)) / (np.nanmax(new_position) - np.nanmin(new_position))
+        signal_norm = (self.data["signal"] - np.min(self.data["signal"])) / (
+                    np.max(self.data["signal"]) - np.min(self.data["signal"]))
+        signal_matrix = np.zeros((self.data["interpolation_resolution"], self.data["number_of_traces"]))
+        signal_matrix[:] = np.NaN
 
-        sorted_first_signal = sig_list[0][pos_list[0].argsort()]
-        first_trace = sorted_first_signal - np.mean(sorted_first_signal)
+        traces_for_testing = zip(np.split(new_position, self.data["trace_cut_index"]),
+                                 np.split(signal_norm, self.data["trace_cut_index"]))
+        i = 0
+        for position, signal in traces_for_testing:
+            # Numpy's interpolation method needs sorted, strictly increasing values
+            signal = signal[np.argsort(position)]
+            position = position[np.argsort(position)]
+            # Since it needs to be strictly increasing, keep only values where x is strictly increasing.
+            # Ignore any other y value when it has the same x value.
+            signal = np.append(signal[0], signal[1:][(np.diff(position) > 0)])
+            position = np.append(position[0], position[1:][(np.diff(position) > 0)])
 
-        all_lags_squared = 0
-        for pos_trace, sig_trace in zip(pos_list, sig_list):
-            current_trace = sig_trace[pos_trace.argsort()]
-            correlation = correlate(first_trace,
-                                    current_trace - np.mean(current_trace), mode="same")
-            lags = correlation_lags(first_trace.size, current_trace.size, mode="same")
-            lag = lags[np.argmax(correlation)]
-            all_lags_squared += lag ** 2
-        if self.debug:
-            print(f"Time sample delay:\t{int(delay)}\tError^2:\t{all_lags_squared:.1e}")
-        return all_lags_squared
+            signal = np.interp(self.interpolated_delay, position, signal)
+            signal_matrix[:, i] = signal
+            if not self.consider_all_traces and i > 100:
+                break
+            i += 1
+        print(f"Delay:\t{delay[0]:.3f}\tError:\t{np.sum(np.nanstd(signal_matrix, axis=1))}")
+        return np.sum(np.nanstd(signal_matrix, axis=1))
 
-    def shift_position(self, delay_value):
-        self.data["signal"] = np.roll(self.data["signal"], delay_value)
-        if delay_value < 0:
-            self.data["position"][delay_value:] = np.nan
-            self.data["signal"][delay_value:] = np.nan
-        else:
-            self.data["position"][:delay_value] = np.nan
-            self.data["signal"][:delay_value] = np.nan
+    def shift_position(self, delay):
+        new_time_axis = delay * self.dt + np.copy(self.original_time)
+        self.data["position"] = self.position_interpolated(new_time_axis)
+        self.data["signal"] = self.data["signal"][~np.isnan(self.data["position"])]
         self.data["position"] = self.data["position"][~np.isnan(self.data["position"])]
-        self.data["signal"] = self.data["signal"][~np.isnan(self.data["signal"])]
+
 
     def butter_filter(self, data, fs, lowcut=None, highcut=None, order=5):
         sos = self._butter_coeff(fs, lowcut, highcut, order=order)
Index: anaTHz/process/post_process_data.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/anaTHz/process/post_process_data.py b/parrot/process/post_process_data.py
rename from anaTHz/process/post_process_data.py
rename to parrot/process/post_process_data.py
--- a/anaTHz/process/post_process_data.py	
+++ b/parrot/process/post_process_data.py	
@@ -107,6 +107,35 @@
             self.applied_functions.append("subtract_polynomial")
             return self.data
 
+    def correct_systematic_errors(self):
+        # This only works when two dark traces were recorded with the same settings as with the light trace
+        if "window" in self.applied_functions:
+            raise NotImplementedError("You already applied a window to the data, "
+                                      "you first have to subtract a polynomial and then apply a window.")
+        elif "FFT" in self.applied_functions:
+            raise NotImplementedError("You already applied a FFT to the data, "
+                                      "you first have to subtract a polynomial and do a FFT.")
+        elif "pad_zeros" in self.applied_functions:
+            raise NotImplementedError("You already applied zero-padding to the data, "
+                                      "you first have to subtract a polynomial and then pad_zeros.")
+        elif "dark1" not in self.data.keys() and "dark2" not in self.data.keys():
+            raise NotImplementedError("Two dark traces missing.")
+        else:
+            dark1_avg = self.data["dark1"]["average"]["time_domain"]
+            dark2_avg = self.data["dark2"]["average"]["time_domain"]
+            min_number_traces = np.min(np.array([self.data["dark1"]["single_traces"].shape[1],
+                                                 self.data["dark2"]["single_traces"].shape[1]]))
+            self.data["dark"] = {"average": {}}
+            self.data["dark"]["light_time"] = self.data["dark1"]["light_time"]
+            self.data["dark"]["number_of_traces"] = min_number_traces
+            self.data["dark"]["single_traces"] = (self.data["dark1"]["single_traces"][:, :min_number_traces]
+                                                - self.data["dark2"]["single_traces"][:, :min_number_traces])
+            self.data["dark"]["average"]["time_domain"] = dark1_avg - dark2_avg
+            self.data["light"]["single_traces"] -= dark1_avg.reshape(-1, 1)
+            self.data["light"]["average"]["time_domain"] -= dark1_avg
+            self.applied_functions.append("correct_systematic_errors")
+            return self.data
+
     def get_statistics(self):
         """
         Basic definition of Dynamic range and Signal-To-Noise ratio as defined in:
diff --git a/anaTHz/my_test_01.py b/parrot/my_test_01.py
rename from anaTHz/my_test_01.py
rename to parrot/my_test_01.py
diff --git a/anaTHz/process/__init__.py b/parrot/process/__init__.py
rename from anaTHz/process/__init__.py
rename to parrot/process/__init__.py
diff --git a/anaTHz/process/cut_data.py b/parrot/process/cut_data.py
rename from anaTHz/process/cut_data.py
rename to parrot/process/cut_data.py
diff --git a/anaTHz/plot/__init__.py b/parrot/plot/__init__.py
rename from anaTHz/plot/__init__.py
rename to parrot/plot/__init__.py
diff --git a/anaTHz/__init__.py b/parrot/__init__.py
rename from anaTHz/__init__.py
rename to parrot/__init__.py
diff --git a/anaTHz/plot/plot.py b/parrot/plot/plot.py
rename from anaTHz/plot/plot.py
rename to parrot/plot/plot.py
diff --git a/anaTHz/load/recording_type.py b/parrot/load/recording_type.py
rename from anaTHz/load/recording_type.py
rename to parrot/load/recording_type.py
diff --git a/anaTHz/load/__init__.py b/parrot/load/__init__.py
rename from anaTHz/load/__init__.py
rename to parrot/load/__init__.py
diff --git a/anaTHz/load/load.py b/parrot/load/load.py
rename from anaTHz/load/load.py
rename to parrot/load/load.py
diff --git a/anaTHz/load/recording_device.py b/parrot/load/recording_device.py
rename from anaTHz/load/recording_device.py
rename to parrot/load/recording_device.py
